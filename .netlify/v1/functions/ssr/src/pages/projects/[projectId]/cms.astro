---
export const prerender = false;
import "../../../styles/cms.css"
// ◆ Layout およびチャートコンポーネントをインポート
import Layout from "../../../layouts/Layout.astro";
import MyLineChart from "../../../components/MyLineChart.jsx";
import Blog from "../../../components/Blog.astro";
import Notice from "../../../components/Notice.astro";

// ◆ Firebase Admin SDK のインポート
import admin from "firebase-admin";
import { initializeApp, cert, getApps, getApp } from "firebase-admin/app";
import { getStorage } from "firebase-admin/storage";

// ユーティリティ関数をインポート
import { 
  createPlaceholder, 
  setupPlaceholderEvents, 
  createTemplateNotification,
  addTemplateContent,
  initializeEditableElement,
  initializeDeleteButton
} from '../../../utils/blogUtils.js';

function formatCreatedAt(createdAt: string | number | Date) {
  if (!createdAt) return "日付未設定";

  // Firestore Timestamp の場合 → createdAt.toDate() で JS Date に変換
  // すでに JS Date の場合はそのまま使う
  const dateObj = createdAt.toDate ? (createdAt as any).toDate() : new Date(createdAt);

  const year = dateObj.getFullYear();
  const month = String(dateObj.getMonth() + 1).padStart(2, "0");
  const day = String(dateObj.getDate()).padStart(2, "0");
  const hour = String(dateObj.getHours()).padStart(2, "0");
  const minute = String(dateObj.getMinutes()).padStart(2, "0");

  return `${year}-${month}-${day} ${hour}:${minute}`;
}


// ----------------------
// ▼ (1) Firebase Admin の初期化
// ----------------------

function getFirebaseApp() {
  if (!getApps().length) {
    initializeApp({
      credential: cert(JSON.parse(import.meta.env.FIREBASE_SERVICE_ACCOUNT)),
      storageBucket: import.meta.env.FIREBASE_STORAGE_BUCKET, // 環境変数から正しいバケット名を設定
    });
  }
  return getApp();
}

async function uploadImageToStorage(file: File, projectId: string, userId: string, uploadType: "user" | "blog") {
  if (!file || typeof file.name !== "string" || file.size <= 0) {
    throw new Error("無効なファイルです。");
  }

  // Firebaseアプリを取得
  const app = getFirebaseApp();
  const bucket = getStorage(app).bucket(import.meta.env.FIREBASE_STORAGE_BUCKET);
  if (!bucket.name) {
    throw new Error("バケット名が設定されていません。環境変数 FIREBASE_STORAGE_BUCKET を確認してください。");
  }

  console.log("✅ Firebase Storage バケット:", bucket.name);

  // **アップロード先のフォルダを uploadType に応じて選択**
  let folderPath = `projects/${projectId}/`;
  if (uploadType === "user") {
    folderPath += `users/${userId}/`;
  } else if (uploadType === "blog") {
    folderPath += `blogThumbnails/`;
  }

  // ファイル名を生成
  const ext = file.name.split(".").pop();
  const fileName = `${folderPath}${Date.now()}_${Math.random().toString(36).slice(2)}.${ext}`;

  // arrayBuffer を Buffer に変換
  const arrayBuffer = await file.arrayBuffer();
  const buffer = Buffer.from(arrayBuffer);

  const fileRef = bucket.file(fileName);
  await fileRef.save(buffer, {
    contentType: file.type,
    public: true,
    metadata: {
      contentType: file.type,
      customMetadata: {
        projectId,
        userId,
        uploadType, // "user" か "blog" かをメタデータに保存
      },
    },
  });

  await fileRef.makePublic();
  return `https://storage.googleapis.com/${bucket.name}/${fileName}`;
}



if (!admin.apps.length) {
  const serviceAccountStr =
    process.env.FIREBASE_SERVICE_ACCOUNT || import.meta.env.FIREBASE_SERVICE_ACCOUNT;
  console.log("Service Account:", serviceAccountStr);
  if (serviceAccountStr) {
    const serviceAccount = JSON.parse(serviceAccountStr);
    const bucketName = import.meta.env.FIREBASE_STORAGE_BUCKET || "test-87192.firebasestorage.app";
    admin.initializeApp({
      credential: admin.credential.cert(serviceAccount),
      storageBucket: bucketName,
    });
  } else {
    console.warn("No Firebase service account found.");
  }
}

const adminAuth = admin.auth();
const db = admin.firestore();

// ----------------------
// ▼ (2) Cookie から token を取り出し、ユーザーのログイン情報を確認
// ----------------------
const cookieHeader = Astro.request.headers.get("cookie") || "";
const cookies = Object.fromEntries(
  cookieHeader.split("; ").filter(Boolean).map((c: { split: (arg0: string) => [any, ...any[]]; }) => {
    const [key, ...v] = c.split("=");
    return [key, v.join("=")];
  })
);
const token = cookies["token"] || "";

let authUser = null;
if (token) {
  try {
    authUser = await adminAuth.verifyIdToken(token);
  } catch (err) {
    console.error("IDトークンの検証に失敗:", err);
  }
}

// ----------------------
// ▼ (3) Firestore からユーザーデータを取得
// ----------------------
let userData = null;
if (authUser) {
  const snap = await db.collection("users").doc(authUser.uid).get();
  if (snap.exists) {
    userData = snap.data();
  }
}

// ----------------------
// ▼ (4) URL パラメータから projectId を取得し、
//       ユーザーが所有する projects[] の中から該当のプロジェクトを検索
// ----------------------
const { projectId } = Astro.params;

let currentProject = null;
if (userData && userData.projects) {
  currentProject = userData.projects.find((p: { id: any; }) => p.id === projectId);
}

if (!currentProject) {
  console.error("該当のプロジェクトが見つかりません");
  return new Response(null, {
    status: 303,
    headers: { Location: "/" },
  });
}

const projectSnap = await db.collection("projects").doc(projectId).get();
const projectData = projectSnap.data() || {};
const existingBlogTags = projectData.blogTags || [];
const existingNewsTags = projectData.newsTags || [];
// ----------------------
// ▼ (5) Layout.astro に渡すための accountName を作成
// ----------------------
const accountName =
  authUser && userData && userData.displayName
    ? userData.displayName
    : "ログイン";

// ----------------------
// ▼ (6) サンプルのグラフ用データ
// ----------------------
const pvLabels = [
  "2025/02/16",
  "2025/02/17",
  "2025/02/18",
  "2025/02/19",
  "2025/02/20",
  "2025/02/21",
  "2025/02/22",
];
const pvDatas = [10, 25, 15, 2, 10, 32, 18];

const ecLabels = [
  "2025/02/16",
  "2025/02/17",
  "2025/02/18",
  "2025/02/19",
  "2025/02/20",
  "2025/02/21",
  "2025/02/22",
];
const ecSalesData = [1800, 2000, 1200, 900, 2200, 1800, 2500];

// ----------------------
// ▼ (7) ページタイトル等を設定
// ----------------------
const pageTitle = "プロジェクト別ページ";

// ----------------------
// ▼ (8) 実際のページをレンダリング
//     Layout には accountName を渡して
//     ナビゲーションにユーザー名を表示できるようにする
// ----------------------

const userId = authUser?.uid || "";

// ▼ (9) blog・notice一覧を取得
let blogList: any[] = [];
let noticeList: any[] = [];

try {
  // blog一覧
  const blogSnap = await db
    .collection("projects")
    .doc(projectId)
    .collection("blog")  // ← サブコレクション名
    // .where("status", "==", "public")  // 公開の記事だけに絞りたい場合は
    .orderBy("createdAt", "desc")  // 投稿日時の降順
    .get();

  blogList = blogSnap.docs.map((doc) => {
    const data = doc.data()
    return {
      id: doc.id,
      ...data,
     dateStr: formatCreatedAt(data.createdAt),
    }
  });

  // notice一覧
  const noticeSnap = await db
    .collection("projects")
    .doc(projectId)
    .collection("notice")  // ← サブコレクション名
    // .where("status", "==", "public")
    .orderBy("createdAt", "desc")  // 投稿日時の降順
    .get();

    noticeList = noticeSnap.docs.map((doc) => {
    const data = doc.data();
    return {
      id: doc.id,
      ...data,
      // フォーマットした文字列を dateStr などに格納しておく
      dateStr: formatCreatedAt(data.createdAt),
    };
  });
} catch (err) {
  console.error("Firestoreからの一覧取得に失敗:", err);
}

let postError = "";
const method = Astro.request.method.toUpperCase();
if (method === "POST") {
  const formData = await Astro.request.formData();
  const action = formData.get("action")?.toString() || "";

  try {
    // 画像アップロード処理
    if (action === "upload_blog_image") {
      const image = formData.get("image");
      const projectId = formData.get("projectId")?.toString() || "";
      
      if (!image || !projectId) {
        return new Response(
          JSON.stringify({ error: "画像またはプロジェクトIDが指定されていません" }),
          { status: 400, headers: { "Content-Type": "application/json" } }
        );
      }
      
      try {
        // Firebase Storageに画像をアップロード
        const imageUrl = await uploadImageToStorage(image, projectId, authUser?.uid || "unknown", "blog-content");
        
        // アップロードされた画像のURLをクライアントに返す
        return new Response(
          JSON.stringify({ imageUrl }),
          { status: 200, headers: { "Content-Type": "application/json" } }
        );
      } catch (err: any) {
        console.error("❌ ブログ画像アップロード失敗:", err.message);
        return new Response(
          JSON.stringify({ error: "画像のアップロードに失敗しました" }),
          { status: 500, headers: { "Content-Type": "application/json" } }
        );
      }
    }
    
    // 既存のブログ投稿処理
    else if (action === "create_blog") {
      // 1) FormData から取得
      const title = formData.get("blogTitle")?.toString() || "";
          
      // 修正: フォームから直接テキストエリアの値を取得
      const blogBody = formData.get("blogTextContent")?.toString() || "";
          
      const submitType = formData.get("submitType")?.toString() || "draft";
      const status = submitType === "publish" ? "public" : "draft";
      const rawTags = formData.getAll("blogTags");
      const file = formData.get("blogThumbnail");
      let thumbnailUrl = "";

      if (file) {
        try {
          thumbnailUrl = await uploadImageToStorage(file, projectId, authUser?.uid || "unknown", "blog");
        } catch (err: any) {
          console.error("❌ サムネイルアップロード失敗:", err.message);
        }
      }

      // デバッグ用にログ出力
      console.log("保存するブログ本文:", blogBody);

      const blogRef = admin.firestore().collection("projects").doc(projectId).collection("blog");
      await blogRef.add({
        title,
        body: blogBody, // ここでbodyフィールドに値を設定
        createdAt: new Date(),
        status,
        tags: rawTags,
        thumbnailUrl,
      });

      // allTags配列にまとめて追加
      const projectDocRef = db.collection("projects").doc(projectId);
        if (rawTags.length > 0) {
           await projectDocRef.update({
            blogTags: admin.firestore.FieldValue.arrayUnion(...rawTags),
          });
        }

      // リダイレクト
      return new Response(null, {
        status: 303,
        headers: { Location: `/projects/${projectId}` },
      });
    }
    
    // 既存のお知らせ投稿処理
    else if (action === "create_notice") {
      // お知らせフォーム
      const title = formData.get("newsTitle")?.toString() || "";
      const body = formData.get("newsBody")?.toString() || "";
      
      // タグ配列
      const newsTags = formData.getAll("newsTags"); // 例: ['イベント', 'グッズ'] など

      // 追加: submitTypeを取得してステータスを設定
      const submitType = formData.get("submitType")?.toString() || "draft";
      const status = submitType === "publish" ? "public" : "draft";

      // Firestore へ追加
      const noticeRef = db
        .collection("projects")
        .doc(projectId)
        .collection("notice");
      await noticeRef.add({
        title: title,
        body: body,
        tags: newsTags,
        createdAt: new Date(),
        status: status, // ステータスを追加
      });

      // allTags配列にまとめて追加
       const projectDocRef = db.collection("projects").doc(projectId);
      if (newsTags.length > 0) {
         await projectDocRef.update({
          newsTags: admin.firestore.FieldValue.arrayUnion(...newsTags),
        });
      }

      // リダイレクト
      return new Response(null, {
        status: 303,
        headers: { Location: `/projects/${projectId}` },
      });
    }
  } catch (err) {
    console.error("投稿時エラー:", err);
    postError = "投稿に失敗しました。";
  }
}
---

<Layout title="Form" userId={userId} accountName={accountName} projects={userData?.projects ?? []}>
  <!-- 削除確認モーダル -->
  <div id="deleteConfirmModal" class="modal">
    <div class="modal_content">
      <h3>ブログ記事の削除</h3>
      <p>このブログ記事を削除してもよろしいですか？</p>
      <p>この操作は取り消せません。</p>
      <div class="modal_confirm">
        <p>確認のため、プロジェクト名を入力してください：</p>
        <p class="modal_project-name">{currentProject?.name || "(No Name)"}</p>
        <input 
          id="confirmProjectName" 
          class="modal_input" 
          placeholder="プロジェクト名を入力"
        />
        <p id="nameError" class="modal_error"></p>
      </div>
      <div class="modal_buttons">
        <button class="modal_button cancel" id="cancelDelete">キャンセル</button>
        <button class="modal_button delete" id="confirmDelete" disabled>削除する</button>
      </div>
    </div>
  </div>

  <div class="pan">
    <p class="pan_item">
      <a href={userId ? `/${userId}` : "/"}>トップ</a>
      <span>
        <svg width="7" height="7" viewBox="0 0 7 7" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M0.456 6.356V5.18L3.156 4.208L4.98 3.548V3.5L3.156 2.828L0.456 1.856V0.692L6.384 2.996V4.04L0.456 6.356Z" fill="#C4C4C4"/>
        </svg>          
      </span>
      <span>{currentProject?.name || "(No Name)"}</span>
      <span>
        <svg width="7" height="7" viewBox="0 0 7 7" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M0.456 6.356V5.18L3.156 4.208L4.98 3.548V3.5L3.156 2.828L0.456 1.856V0.692L6.384 2.996V4.04L0.456 6.356Z" fill="#C4C4C4"/>
        </svg>          
      </span>
      <span>CMS</span>
    </p>
  </div>
  <nav class="nav">
    <button class="nav_btn">
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g clip-path="url(#clip0_623_115)">
        <path fill-rule="evenodd" clip-rule="evenodd" d="M10.4712 7.52879C10.5962 7.65381 10.6664 7.82334 10.6664 8.00012C10.6664 8.1769 10.5962 8.34644 10.4712 8.47145L6.6999 12.2428C6.63841 12.3065 6.56484 12.3572 6.48351 12.3922C6.40217 12.4271 6.31469 12.4455 6.22617 12.4463C6.13765 12.4471 6.04986 12.4302 5.96793 12.3967C5.886 12.3631 5.81157 12.3136 5.74897 12.251C5.68638 12.1885 5.63688 12.114 5.60336 12.0321C5.56983 11.9502 5.55297 11.8624 5.55374 11.7739C5.55451 11.6853 5.5729 11.5979 5.60784 11.5165C5.64277 11.4352 5.69356 11.3616 5.75724 11.3001L9.05724 8.00012L5.75724 4.70012C5.6358 4.57439 5.5686 4.40598 5.57012 4.23119C5.57164 4.05639 5.64175 3.88918 5.76536 3.76557C5.88896 3.64197 6.05617 3.57186 6.23097 3.57034C6.40577 3.56882 6.57417 3.63601 6.6999 3.75745L10.4712 7.52879Z" fill="white"/>
        </g>
        <defs>
        <clipPath id="clip0_623_115">
        <rect width="16" height="16" fill="white"/>
        </clipPath>
        </defs>
      </svg>        
    </button>
    <ul class="nav_list">
      <li class="nav_item">
        <a href=`/projects/${projectId}` class="nav_link" id="switch-btn">サマリー</a>
      </li>
      <li class="nav_item">
        <a href=`/projects/${projectId}/profile` class="nav_link" id="switch-btn">プロフィール</a>
      </li>
      <li class="nav_item">
        <a href=`/projects/${projectId}/form` class="nav_link" id="switch-btn">フォーム</a>
      </li>
      <li class="nav_item">
        <a href=`/projects/${projectId}` class="nav_link active" id="switch-btn">CMS</a>
      </li>
      <li class="nav_item">
        <a href=`/projects/${projectId}` class="nav_link" id="switch-btn">アナリティクス</a>
      </li>
      <li class="nav_item">
        <a href=`/projects/${projectId}` class="nav_link" id="switch-btn">プレビュー</a>
      </li>
      <li class="nav_item">
        <a href=`/projects/${projectId}` class="nav_link" id="switch-btn">プレビュー</a>
      </li>
    </ul>
  </nav>

  <div class="container" id="switch">
    <div class="cms-box">
      <div class="inner">
        <div class="box_title-wrapper">
          <div class="box_title-wrapper_left">
            <p class="box_title">CMS</p>
            <p class="box_desc">ブログやお知らせなどのコンテンツを導入し、投稿・更新することができます。</p>
          </div>
          <div class="box_title-wrapper_right">
            <p class="box_title-wrapper_right_label">
              追加可能コンテンツ数
              <strong>0</strong>
            </p>
            <button class="box_title-wrapper_right_btn">
              アップグレードしてCMSの枠を増やす
            </button>
          </div>
        </div>
        <div class="box_cms">
          <p>コンテンツ <span>2/2</span></p>
          <ul class="box_cms-list">
            <li class="box_cms-item active" data-target="notice-panel">お知らせ</li>
            <li class="box_cms-item" data-target="blog-panel">ブログ</li>
            <li>
              <button class="box_cms_number">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M18 12.998H13V17.998C13 18.2633 12.8946 18.5176 12.7071 18.7052C12.5196 18.8927 12.2652 18.998 12 18.998C11.7348 18.998 11.4804 18.8927 11.2929 18.7052C11.1054 18.5176 11 18.2633 11 17.998V12.998H6C5.73478 12.998 5.48043 12.8927 5.29289 12.7052C5.10536 12.5176 5 12.2633 5 11.998C5 11.7328 5.10536 11.4785 5.29289 11.2909C5.48043 11.1034 5.73478 10.998 6 10.998H11V5.99805C11 5.73283 11.1054 5.47848 11.2929 5.29094C11.4804 5.1034 11.7348 4.99805 12 4.99805C12.2652 4.99805 12.5196 5.1034 12.7071 5.29094C12.8946 5.47848 13 5.73283 13 5.99805V10.998H18C18.2652 10.998 18.5196 11.1034 18.7071 11.2909C18.8946 11.4785 19 11.7328 19 11.998C19 12.2633 18.8946 12.5176 18.7071 12.7052C18.5196 12.8927 18.2652 12.998 18 12.998Z" fill="white"/>
                </svg>              
                <p>あと 0</p>
              </button>
            </li>
          </ul>
        </div>
      </div>
    </div>
    <!-- <div class="box_header">
      <p class="box_desc">お知らせを投稿・編集できます</p>
      <div class="box_btn_wrapper">
        <button class="box_btn">キャンセル</button>
        <button id="save-btn"  class="box_btn save">公開</button>
      </div>
    </div> -->

    <div class="cms_contents">
      
      <Blog existingBlogTags={existingBlogTags} blogList={blogList} />
      <!-- お知らせタブ -->
      <Notice existingNewsTags={existingNewsTags} noticeList={noticeList} />
    </div>

  </div>
</Layout>

<style lang="scss">
  .pan{
    margin-top: 8px;
    
    &_item{
      display: flex;
      gap: 8px;
      color: var(--sub-font-color);
      font-size: var(--font-size-xs);
      font-weight: 300;

      >a{
        color: var(--main-font-color);
      }
    }
  }

  .nav{
    position: relative;
    margin-top: 16px;
    width: 100%;
    overflow: hidden;
    border-radius: var(--border-radius-m);
    background-color: var(--sub-bg-color);
    border: 1px solid var(--main-border-color);

    &_btn{
      position: absolute;
      right: 0;
      height: 100%;
      padding: 0 8px;
      background-color: var(--sub-bg-color);
      border-left: 1px solid var(--main-border-color);
      z-index: 10;
    }

    &_list{
      width: 100%;
      display: flex;
      flex-wrap: nowrap;
      gap: 8px;
      align-items: center;
      padding-inline: 24px;
      overflow-x: auto;
    }

    &_item{
      >.active{
        color: var(--main-font-color);
        border-bottom: 1px solid var(--accent-bg-color);
      }
    }

    &_link{
      position: relative;
      padding: 16px 40px;
      text-wrap: nowrap;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--sub-font-color);
      font-size: var(--font-size-xs);
      font-weight: 400;
      transition: all .2s;

      &:hover{
        color: var(--main-font-color);
        transition: all .2s;

        &::after{
          content: "";
          position: absolute;
          bottom: 0;
          height: 1px;
          background-color: var(--accent-bg-color);
          animation: nav_border .2s forwards;

          @keyframes nav_border {
            0%{
              width: 0;
            }
            100%{
              width: 100%;
            }
          }
        }
      }
    }
  }

  .cms-box{
    width: 100%;
		background-color: var(--sub-bg-color);
		border: 1px solid var(--main-border-color);
		border-radius: var(--border-radius-m);
		margin-top: 16px;

    >.inner{
			padding: 16px 16px 16px 24px;
		}
  }

  .box{
		width: calc(100% - 32px);
    margin-inline: 16px;
		background-color: var(--sub-bg-color);
		border: 1px solid var(--main-border-color);
		border-radius: var(--border-radius-m);
		margin-top: 8px;

		&:first-of-type{
			margin-top: 16px;
		}

		>.inner{
			padding: 16px;
		}

    &_title-wrapper{
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;

      &_left{
        display: flex;
        flex-direction: column;
        gap: 16px;

        >.box_title{
          font-size: var(--font-size-l);
          font-weight: 500;
          color: var(--main-font-color);
        }
      }

      &_right{
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
        padding: 16px;
        background-color: var(--btn-bg-color);
        border-radius: var(--border-radius-m);
        border: 1px solid var(--main-border-color);

        &_label{
          font-size: var(--font-size-xxs);
          color: var(--sub-font-color);

          >strong{
            margin-left: 8px;
          }
        }

        &_btn{
          padding: 12px 16px;
          background-color: var(--accent-bg-color);
          border-radius: var(--border-radius-m);
          color: var(--main-font-color);
          font-size: var(--font-size-xxs);
        }
      }
    }

    &_cms{
      margin-top: 16px;

      >p{
        color: var(--sub-font-color);
        font-size: var(--font-size-xs);
      }

      &_number{
        height: 40px;
        display: flex;
        align-items: center;
        gap: 4px;
        font-size: var(--font-size-xxs);
        color: var(--main-font-color);
        border: 1px solid var(--main-border-color);
        border-radius: var(--border-radius-m);
        // background-color: var(--item-bg-color);
        padding: 0 12px;
      }

      &-list{
        margin-top: 16px;
        display: flex;
        gap: 8px;
        align-items: center;

        >.active{
          background-color: var(--item-bg-color);
          color: var(--main-font-color);
          border: 1px solid var(--main-border-color);
        }
      }

      &-item{
        display: flex;
        align-items: center;
        height: 40px;
        padding: 0 16px;
        border-radius: var(--border-radius-m);
        color: var(--sub-font-color);
        font-size: var(--font-size-xs);
        cursor: pointer;
      }
    }

    &_header{
      margin-top: 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    &_desc{
      font-size: var(--font-size-xs);
      font-weight: 400;
      color: var(--sub-font-color);
    }

    &_label{
      font-size: var(--font-size-s);
      color: var(--main-font-color);
    }

    &_btn{
      padding: 12px 16px;
      border-radius: var(--border-radius-m);
      font-size: var(--font-size-xxs);
      color: var(--main-font-color);
      border: 1px solid var(--sub-border-color);

      &_wrapper{
        display: flex;
        align-items: center;
        gap: 8px;

        >.save{
          color: var(--main-font-color);
          background-color: var(--accent-bg-color);
          border: 1px solid var(--accent-bg-color);
        }
      }
    }
  }

  .contents{
    width: calc(100% - 32px);
    margin-top: 40px;
    margin-inline: 16px;
    padding-top: 40px;
    border-top: 1px solid var(--main-border-color);
  }
  .posted{
    width: calc(100% - 32px);
    margin-top: 40px;
    padding-top: 40px;
    margin-inline: 16px;
    border-top: 1px solid var(--main-border-color);

    &_label{
      font-size: var(--font-size-s);
      color: var(--main-font-color);
    }

    &_blog{

      &-list{
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        row-gap: 24px;
        column-gap: 16px;
        margin-top: 24px;
      }

      &-item{
        cursor: pointer;

        >img{
          width: 100%;
          aspect-ratio: 16/9;
          object-fit: cover;
          border-radius: var(--border-radius-s);
        }
        >p{
          margin-top: 8px;
          display: flex;
          align-items: center;
          gap: 8px;
          color: var(--sub-font-color);
          font-size: var(--font-size-xxs);

          >.slash{
            width: 1px;
            height: 12px;
            background-color: var(--sub-border-color);
          }
        }
        >h4{
          margin-top: 8px;
          font-size: var(--font-size-s);
          color: var(--main-font-color);
        }

        &_btns{
          margin-top: 8px;
          display: flex;
          align-items: center;
          gap: 8px;
          justify-content: right;
        }
      }
    }

    &_list{
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 24px;
    }

    &_item{
      padding: 16px;
      border-radius: var(--border-radius-m);
      background-color: var(--sub-bg-color);
      display: flex;
      align-items: center;
      gap: 16px;
      cursor: pointer;

      &_title{
        font-size: var(--font-size-s);
        color: var(--main-font-color);
      }

      &_info{
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 16px;

        >p{
          display: flex;
          align-items: center;
          gap: 8px;
          font-size: var(--font-size-xs);
          color: var(--sub-font-color);

          >.slash{
            width: 1px;
            height: 12px;
            background-color: var(--sub-border-color);
          }
        }
      }

      &_btns{
        display: flex;
        align-items: center;
        gap: 8px;

        >button{
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: var(--border-radius-s);
        }
      }

      &_btn{
        width: 32px;
        height: 32px;
        background-color: var(--btn-bg-color);
        border: 1px solid var(--main-border-color);
      }
    }
  }

  .info_number_wrapper{
    margin-top: 16px;
    display: flex;
    align-items: center;
    gap: 24px;
  }

  .info_number{
    color: var(--sub-font-color);
    font-size: var(--font-size-xs);

    >.number{
      font-weight: 500;
      color: var(--main-font-color);
      font-size: var(--font-size-s);
    }
  }

  .option_box{
    margin-top: 24px;
  }

  .subject_wrapper{
    display: flex;
    align-items: center;
    gap: 8px;

    >.active{
      background-color: var(--item-bg-color);
      color: var(--main-font-color);
    }

    >button{
      padding: 8px 16px;
      border: 1px solid var(--main-border-color);
      border-radius: var(--border-radius-s);
      font-size: var(--font-size-xs);
      color: var(--sub-font-color);
    }
  }

  .option_wrapper{
    margin-top: 16px;
    display: flex;
    align-items: center;
    gap: 16px;
  }

  .option{
    display: flex;
    align-items: center;

    >input{
      margin-right: 8px;
    }
    >svg{
      margin-right: 4px;
    }
    >label{
      color: var(--main-font-color);
      font-size: var(--font-size-xs);
    }
  }


  .box_action_btns{
    position: absolute;
    right: 16px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .item_action_btns{
    display: flex;
    align-items: center;
    gap: 8px;
    margin-left: 8px;
    margin-top: 2px;
  }

  .subject_label{
    font-size: var(--font-size-xs);
    color: var(--main-font-color);
  }
  
  .visibox{
    position: absolute;
    right: 16px;
    display: flex;
    // align-items: center;
    gap: 4px;

    >label{
      font-size: var(--font-size-xxs);
      color: var(--sub-font-color);
    }
    >input{
      border: none;
    }
  }

  .option{
    display: flex;
    align-items: center;

    >input{
      margin-right: 8px;
    }
    >svg{
      margin-right: 4px;
    }
    >label{
      color: var(--main-font-color);
      font-size: var(--font-size-xs);
    }
  }

  /* モーダルのスタイル */
  .modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 1000;
    
    &_content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: var(--sub-bg-color);
      padding: 24px;
      border-radius: var(--border-radius-m);
      width: 90%;
      max-width: 400px;
      
      h3 {
        color: var(--main-font-color);
        font-size: var(--font-size-l);
        margin-bottom: 16px;
      }
      
      p {
        color: var(--sub-font-color);
        font-size: var(--font-size-m);
        margin-bottom: 8px;
      }
      
      .modal_confirm {
        margin: 24px 0;
        
        .modal_project-id {
          font-weight: bold;
          color: var(--main-font-color);
          margin: 8px 0;
        }
        
        .modal_input {
          width: 100%;
          padding: 8px 16px;
          margin: 8px 0;
          background: var(--item-bg-color);
          border: 1px solid var(--main-border-color);
          border-radius: var(--border-radius-s);
          color: var(--main-font-color);
          
          &:focus {
            outline: none;
            border-color: var(--accent-bg-color);
          }
        }
        
        .modal_error {
          color: var(--delete-bg-color);
          font-size: var(--font-size-s);
          min-height: 20px;
        }
      }
    }
    
    &_buttons {
      display: flex;
      gap: 16px;
      margin-top: 24px;
      justify-content: flex-end;
    }
    
    &_button {
      padding: 8px 24px;
      border-radius: var(--border-radius-s);
      font-size: var(--font-size-m);
      cursor: pointer;
      
      &.cancel {
        background-color: var(--elem-bg-color);
        color: var(--main-font-color);
      }
      
      &.delete {
        background-color: var(--delete-bg-color);
        color: var(--main-font-color);
        
        &:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }
      }
    }
  }
</style>


<script>
  
// ① すべての blog-elems_elem ボタンを取得
const blogElemButtons = document.querySelectorAll('.blog-elems_elem');
// ② blog要素（本文表示領域）を取得
const blogContainer = document.querySelector('.blog');
// フォーム要素を取得
const blogForm = document.querySelector('form.cms');
const blogBodyInput = document.getElementById('blogBodyInput') as HTMLInputElement;

if (blogForm && blogContainer && blogBodyInput) {
  blogForm.addEventListener('submit', () => {
    // 例: 現在の .blog コンテナ内のHTMLを文字列として取得
    const html = blogContainer.innerHTML;

    // hiddenフィールドにセット
    blogBodyInput.value = html;
  });
}


// ③ ボタンがクリックされたら、data-type を見て対応するHTMLを挿入
blogElemButtons.forEach((btn) => {
  btn.addEventListener('click', (e) => {
    e.preventDefault(); // formボタンなどの既定動作を止める
    if (!blogContainer) return;

    // data-type を取得 (heading1, heading2, heading3, text, image, link ...)
    const type = btn.dataset.type;

    // 追加したいHTML を用意
    const snippet = getSnippetHTML(type);
    if (!snippet) return;

    // 新しい要素を生成 → .blog内に追加
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = snippet.trim();
    const newBlock = tempDiv.firstElementChild;
    blogContainer.appendChild(newBlock);

    // ブロック挿入直後の初期化：contenteditable要素に blur イベント仕込み・フォーカスなど
    initializeBlock(newBlock, type);
  });
});

/**
 * タイプごとに追加する HTML を返す関数
 * - heading1, heading2, heading3, text は contenteditable
 * - image は 16:9 の灰色枠をクリック → hidden input をクリック という構造
 */
function getSnippetHTML(type: any) {
  switch (type) {
    case 'heading1':
      return `
        <div class="blog_wrapper" data-type="heading1">
          <div class="blog_content">
            <h2 contenteditable="true">大見出し (H2想定)</h2>
          </div>
          <div class="blog_action-btns">
            <button class="blog_action-btn">
              <svg width="20" height="20" viewBox="0 0 20 20" fill="none"
                  xmlns="http://www.w3.org/2000/svg">
                <path d="M7.05273 12.9454L12.9461 7.05371M7.05273 7.05371
                         L12.9461 12.9454"
                      stroke="#C4C4C4" stroke-linecap="round"/>
              </svg>
            </button>
          </div>
        </div>
      `;
    case 'heading2':
      return `
        <div class="blog_wrapper" data-type="heading2">
          <div class="blog_content">
            <h3 contenteditable="true">中見出し (H3想定)</h3>
          </div>
          <div class="blog_action-btns">
            <button class="blog_action-btn">
              <svg width="20" height="20" viewBox="0 0 20 20" fill="none"
                  xmlns="http://www.w3.org/2000/svg">
                <path d="M7.05273 12.9454L12.9461 7.05371M7.05273 7.05371
                         L12.9461 12.9454"
                      stroke="#C4C4C4" stroke-linecap="round"/>
              </svg>
            </button>
          </div>
        </div>
      `;
    case 'heading3':
      return `
        <div class="blog_wrapper" data-type="heading3">
          <div class="blog_content">
            <h4 contenteditable="true">小見出し (H4想定)</h4>
          </div>
          <div class="blog_action-btns">
            <button class="blog_action-btn">
              <svg width="20" height="20" viewBox="0 0 20 20" fill="none"
                  xmlns="http://www.w3.org/2000/svg">
                <path d="M7.05273 12.9454L12.9461 7.05371M7.05273 7.05371
                         L12.9461 12.9454"
                      stroke="#C4C4C4" stroke-linecap="round"/>
              </svg>
            </button>
          </div>
        </div>
      `;
    case 'text':
      return `
        <div class="blog_wrapper" data-type="text">
          <div class="blog_content">
            <p contenteditable="true">テキスト</p>
          </div>
          <div class="blog_action-btns">
            <button class="blog_action-btn">
              <svg width="20" height="20" viewBox="0 0 20 20" fill="none"
                  xmlns="http://www.w3.org/2000/svg">
                <path d="M7.05273 12.9454L12.9461 7.05371M7.05273 7.05371
                         L12.9461 12.9454"
                      stroke="#C4C4C4" stroke-linecap="round"/>
              </svg>
            </button>
          </div>
        </div>
      `;
    // case 'image':
    //   return `
    //     <div class="blog_wrapper" data-type="image">
    //       <div class="blog_content" style="display:flex; align-items:center;">
    //         <!-- クリック可能な16:9枠 -->
    //         <div class="image-placeholder" 
    //              style="width:280px; aspect-ratio:16/9; background:#666; 
    //                     cursor:pointer; display:flex; align-items:center; 
    //                     justify-content:center; border-radius:4px;">
    //           <span style="color:#aaa; font-size:12px;">画像を選択</span>
    //           <!-- 実際の file input は隠しておく -->
    //           <input type="file" accept="image/*" style="display:none;" />
    //         </div>
    //       </div>
    //       <div class="blog_action-btns">
    //         <button class="blog_action-btn">
    //           <svg width="20" height="20" viewBox="0 0 20 20" fill="none"
    //               xmlns="http://www.w3.org/2000/svg">
    //             <path d="M7.05273 12.9454L12.9461 7.05371M7.05273 7.05371
    //                      L12.9461 12.9454"
    //                   stroke="#C4C4C4" stroke-linecap="round"/>
    //           </svg>
    //         </button>
    //       </div>
    //     </div>
    //   `;
    case 'link':
      return `
        <div class="blog_wrapper" data-type="link">
          <div class="blog_content">
            <div class="link_wrapper">
              <p>リンク:</p>
              <input type="text" placeholder="リンクURLを入力" />
            </div>
            <div class="link_wrapper">
              <p>表示テキスト:</p>
              <input type="text" placeholder="表示テキストを入力" />
            </div>
          </div>
          <div class="blog_action-btns">
            <button class="blog_action-btn">
              <svg width="20" height="20" viewBox="0 0 20 20" fill="none"
                  xmlns="http://www.w3.org/2000/svg">
                <path d="M7.05273 12.9454L12.9461 7.05371
                         M7.05273 7.05371L12.9461 12.9454"
                      stroke="#C4C4C4" stroke-linecap="round"/>
              </svg>
            </button>
          </div>
        </div>
      `;
    default:
      return null; // 不明な type
  }
}

/**
 * ブロック挿入直後の初期化処理
 * - contenteditable要素の場合、全選択してfocus、blur時の削除判定を仕込む
 * - 画像ブロックの場合、クリックで file input を開く処理を仕込む
 */
 function initializeBlock(newBlock: Element | null, type: string) {
  if (!newBlock) return;

  // (A) contenteditable 要素があればフォーカス＆全選択＆blur時空なら削除
  const editable = newBlock.querySelector('[contenteditable="true"]');
  if (editable) {
    editable.focus();
    const range = document.createRange();
    range.selectNodeContents(editable);
    const sel = window.getSelection();
    if (sel) {
      sel.removeAllRanges();
      sel.addRange(range);
    }

    editable.addEventListener('blur', () => {
      const blockType = newBlock.dataset.type;
      if (!blockType) return;
      if ((blockType === 'heading' || blockType === 'text') 
          && editable.textContent.trim() === '') {
        newBlock.remove();
      }
    });
  }

  // (B) 画像ブロックの場合 → 枠をクリックすると input[type="file"] を呼び出して画像をプレビューする
  if (type === 'image') {
    const imagePlaceholder = newBlock.querySelector('.image-placeholder');
    const fileInput = newBlock.querySelector('input[type="file"]');

    if (imagePlaceholder && fileInput) {
      // クリック → fileInput.click()
      imagePlaceholder.addEventListener('click', () => {
        fileInput.click();
      });

      // ファイル選択後にプレビュー表示
      fileInput.addEventListener('change', (ev: { target: { files: any[]; }; }) => {
        const file = ev.target.files?.[0];
        if (!file) return;

        // 画像のURLを生成
        const imageUrl = URL.createObjectURL(file);

        // ① 単純に枠内に <img> を差し込む場合
        imagePlaceholder.innerHTML = `
          <img src="${imageUrl}" alt="preview" 
               style="width:100%; height:auto; object-fit:cover; border-radius:4px;" />
        `;

        // ② あるいは、CSSの background-image で差し込む場合
        //    imagePlaceholder.style.backgroundImage = `url("${imageUrl}")`;
        //    imagePlaceholder.style.backgroundSize = 'cover';
        //    imagePlaceholder.style.backgroundPosition = 'center';
        //    // 文字や <input> は不要になるため削除
        //    imagePlaceholder.innerHTML = ''; 

        // ※ 不要になったら後で URL.revokeObjectURL(imageUrl) してもOK
      });
    }
  }
}

/**
 * ⑥ 追加したブロックを削除する機能（×ボタン）: イベント委譲
 */
if (blogContainer) {
  blogContainer.addEventListener("click", (ev) => {
    const delButton = ev.target.closest(".blog_action-btn");
    if (!delButton) return; // ×ボタン以外なら無視

    const wrapper = delButton.closest(".blog_wrapper");
    if (wrapper) {
      wrapper.remove(); // ブロック削除
    }
  });
}

// 「タグを追加」ボタンと fieldset を取得
const addTagBtn = document.getElementById("addNewsBtn");
const tagFieldset = document.getElementById("tag-fieldset");
// フィールドセットへのクリックを一括で管理する (イベント委譲)
if (tagFieldset) {
  tagFieldset.addEventListener("click", (ev) => {
    // (A) 削除ボタンが押されたとき
    const delBtn = ev.target.closest(".delete-tag-btn");
    if (delBtn) {
      // 親のラッパ要素 (div.cms-body_wrapper) を削除する
      // 先に確認ダイアログを出す場合は下記のように
      if (!confirm("このタグを削除してよろしいですか？")) return;
      const wrapper = delBtn.closest(".cms-body_wrapper");
      if (wrapper) wrapper.remove();
      return;
    }

    // (B) 編集ボタンが押されたとき
    const editBtn = ev.target.closest(".edit-tag-btn");
    if (editBtn) {
      // 同じ行の label を contenteditable にしてフォーカス
      const wrapper = editBtn.closest(".cms-body_wrapper");
      if (!wrapper) return;
      const labelEl = wrapper.querySelector("label");
      if (!labelEl) return;

      // 編集を許可
      labelEl.setAttribute("contenteditable", "true");
      labelEl.focus();

      // 全選択（モダンブラウザの場合）
      if (window.getSelection && document.createRange) {
        const range = document.createRange();
        range.selectNodeContents(labelEl);
        const sel = window.getSelection();
        if (sel) {
          sel.removeAllRanges();
          sel.addRange(range);
        }
      } else {
        // 古いブラウザ向け
        document.execCommand("selectAll", false, null);
      }

      // blur で編集完了 → contenteditable を外す
      labelEl.addEventListener(
        "blur",
        () => {
          labelEl.removeAttribute("contenteditable");

          const checkbox = wrapper.querySelector('input[type="checkbox"]');
          if (checkbox) {
            checkbox.value = labelEl.textContent.trim() || "無題タグ";
          }

          // もし空文字になっていたら削除 or 何らかのエラー表示など
          if (labelEl.textContent.trim() === "") {
            if (!confirm("タグ名が空です。削除してよいですか？")) {
              // 元に戻したい場合は適宜処理
              labelEl.textContent = "新しいタグ";
            } else {
              wrapper.remove();
            }
          }
        },
        { once: true }
      );

      return;
    }
  });
}

if (addTagBtn && tagFieldset) {
  addTagBtn.addEventListener("click", () => {
    // 一意のIDを生成（ID衝突を防ぐため）
    const uniqueId = "cms-tag-" + Math.random().toString(36).slice(2);

    // 新たに追加するタグ用のラッパ (div)
    const newTagWrapper = document.createElement("div");
    newTagWrapper.className = "cms-body_wrapper";

    // 中身として「チェックボックス + ラベル」を用意
    // ラベル部分を contenteditable にするか、あるいは <input type="text"> にするかはお好みでOK
    newTagWrapper.innerHTML = `
      <input type="checkbox" id="${uniqueId}" name="newsTags" value="新しいタグ">
      <label for="${uniqueId}">新しいタグ</label>
      <span class="item_action_btns">
        <button type="button" class="edit-tag-btn" data-id="${uniqueId}">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
             <path fill-rule="evenodd" clip-rule="evenodd" d="M21.4559 5.41632C21.5509 5.56052 21.5932 5.7331 21.5757 5.9049C21.5582 6.07671 21.482 6.23721 21.3599 6.35932L12.1669 15.5513C12.0728 15.6453 11.9555 15.7126 11.8269 15.7463L7.99787 16.7463C7.8713 16.7793 7.7383 16.7787 7.61206 16.7444C7.48583 16.7101 7.37076 16.6434 7.27826 16.5509C7.18577 16.4584 7.11908 16.3434 7.0848 16.2171C7.05053 16.0909 7.04986 15.9579 7.08287 15.8313L8.08287 12.0033C8.11277 11.8887 8.16776 11.7821 8.24387 11.6913L17.4709 2.47032C17.6115 2.32987 17.8021 2.25098 18.0009 2.25098C18.1996 2.25098 18.3902 2.32987 18.5309 2.47032L21.3599 5.29832C21.3948 5.33516 21.4269 5.3746 21.4559 5.41632ZM19.7689 5.82832L18.0009 4.06132L9.48287 12.5793L8.85787 14.9723L11.2509 14.3473L19.7689 5.82832Z" fill="#C4C4C4"/>
             <path d="M19.641 17.1601C19.9143 14.824 20.0016 12.47 19.902 10.1201C19.8997 10.0647 19.9089 10.0094 19.929 9.95778C19.9491 9.90614 19.9798 9.85925 20.019 9.82008L21.003 8.83608C21.0299 8.80904 21.064 8.79033 21.1013 8.78222C21.1385 8.77411 21.1774 8.77693 21.2131 8.79034C21.2488 8.80375 21.2798 8.82719 21.3025 8.85783C21.3252 8.88847 21.3386 8.92502 21.341 8.96308C21.5257 11.7543 21.4554 14.5566 21.131 17.3351C20.895 19.3571 19.271 20.9421 17.258 21.1671C13.7633 21.5538 10.2367 21.5538 6.74201 21.1671C4.73001 20.9421 3.10501 19.3571 2.86901 17.3351C2.45512 13.7905 2.45512 10.2097 2.86901 6.66508C3.10501 4.64308 4.72901 3.05808 6.74201 2.83308C9.39446 2.54012 12.0667 2.46888 14.731 2.62008C14.7691 2.62281 14.8057 2.63642 14.8363 2.65929C14.867 2.68215 14.8904 2.71332 14.9039 2.7491C14.9173 2.78487 14.9203 2.82376 14.9123 2.86115C14.9044 2.89854 14.8859 2.93287 14.859 2.96008L13.866 3.95208C13.8272 3.99092 13.7808 4.02136 13.7297 4.04149C13.6786 4.06162 13.6239 4.07101 13.569 4.06908C11.3458 3.99293 9.11993 4.07815 6.90901 4.32408C6.26295 4.39558 5.65986 4.6828 5.19717 5.13933C4.73447 5.59586 4.43919 6.19504 4.35901 6.84008C3.95787 10.2684 3.95787 13.7318 4.35901 17.1601C4.43919 17.8051 4.73447 18.4043 5.19717 18.8608C5.65986 19.3174 6.26295 19.6046 6.90901 19.6761C10.264 20.0511 13.736 20.0511 17.092 19.6761C17.7381 19.6046 18.3412 19.3174 18.8039 18.8608C19.2666 18.4043 19.5608 17.8051 19.641 17.1601Z" fill="#C4C4C4"/>
          </svg>
        </button>
        <button type="button" class="delete-tag-btn" data-id="${uniqueId}">
          <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
           <path d="M7.05273 12.9454L12.9461 7.05371M7.05273 7.05371L12.9461 12.9454" stroke="#C4C4C4" stroke-linecap="round"/>
          </svg>
        </button>
      </span>
    `;

    // fieldset 内で「追加ボタン」の直前に挿入
    tagFieldset.insertBefore(newTagWrapper, addTagBtn);

    // もしラベルをすぐ編集したいならフォーカスを当てる
    const labelEl = newTagWrapper.querySelector("label[contenteditable]");
    if (labelEl) {
      // キャレットを末尾に持っていきたい場合
      labelEl.focus();
      document.execCommand("selectAll", false, null); // すべて選択
    }
  });



  const addBlogTagBtn = document.getElementById("addBlogTagBtn");
  const blogTagFieldset = document.getElementById("blog-tag-fieldset");
  if (addBlogTagBtn && blogTagFieldset) {
    addBlogTagBtn.addEventListener("click", () => {
      const uniqueId = "blog-tag-" + Math.random().toString(36).slice(2);
      const newTagWrapper = document.createElement("div");
      newTagWrapper.className = "cms-body_wrapper";

      newTagWrapper.innerHTML = `
      <input type="checkbox" id="${uniqueId}" name="blogTags" value="新しいタグ">
      <label for="${uniqueId}">新しいタグ</label>
      <span class="item_action_btns">
        <button type="button" class="edit-tag-btn" data-id="${uniqueId}">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
             <path fill-rule="evenodd" clip-rule="evenodd" d="M21.4559 5.41632C21.5509 5.56052 21.5932 5.7331 21.5757 5.9049C21.5582 6.07671 21.482 6.23721 21.3599 6.35932L12.1669 15.5513C12.0728 15.6453 11.9555 15.7126 11.8269 15.7463L7.99787 16.7463C7.8713 16.7793 7.7383 16.7787 7.61206 16.7444C7.48583 16.7101 7.37076 16.6434 7.27826 16.5509C7.18577 16.4584 7.11908 16.3434 7.0848 16.2171C7.05053 16.0909 7.04986 15.9579 7.08287 15.8313L8.08287 12.0033C8.11277 11.8887 8.16776 11.7821 8.24387 11.6913L17.4709 2.47032C17.6115 2.32987 17.8021 2.25098 18.0009 2.25098C18.1996 2.25098 18.3902 2.32987 18.5309 2.47032L21.3599 5.29832C21.3948 5.33516 21.4269 5.3746 21.4559 5.41632ZM19.7689 5.82832L18.0009 4.06132L9.48287 12.5793L8.85787 14.9723L11.2509 14.3473L19.7689 5.82832Z" fill="#C4C4C4"/>
             <path d="M19.641 17.1601C19.9143 14.824 20.0016 12.47 19.902 10.1201C19.8997 10.0647 19.9089 10.0094 19.929 9.95778C19.9491 9.90614 19.9798 9.85925 20.019 9.82008L21.003 8.83608C21.0299 8.80904 21.064 8.79033 21.1013 8.78222C21.1385 8.77411 21.1774 8.77693 21.2131 8.79034C21.2488 8.80375 21.2798 8.82719 21.3025 8.85783C21.3252 8.88847 21.3386 8.92502 21.341 8.96308C21.5257 11.7543 21.4554 14.5566 21.131 17.3351C20.895 19.3571 19.271 20.9421 17.258 21.1671C13.7633 21.5538 10.2367 21.5538 6.74201 21.1671C4.73001 20.9421 3.10501 19.3571 2.86901 17.3351C2.45512 13.7905 2.45512 10.2097 2.86901 6.66508C3.10501 4.64308 4.72901 3.05808 6.74201 2.83308C9.39446 2.54012 12.0667 2.46888 14.731 2.62008C14.7691 2.62281 14.8057 2.63642 14.8363 2.65929C14.867 2.68215 14.8904 2.71332 14.9039 2.7491C14.9173 2.78487 14.9203 2.82376 14.9123 2.86115C14.9044 2.89854 14.8859 2.93287 14.859 2.96008L13.866 3.95208C13.8272 3.99092 13.7808 4.02136 13.7297 4.04149C13.6786 4.06162 13.6239 4.07101 13.569 4.06908C11.3458 3.99293 9.11993 4.07815 6.90901 4.32408C6.26295 4.39558 5.65986 4.6828 5.19717 5.13933C4.73447 5.59586 4.43919 6.19504 4.35901 6.84008C3.95787 10.2684 3.95787 13.7318 4.35901 17.1601C4.43919 17.8051 4.73447 18.4043 5.19717 18.8608C5.65986 19.3174 6.26295 19.6046 6.90901 19.6761C10.264 20.0511 13.736 20.0511 17.092 19.6761C17.7381 19.6046 18.3412 19.3174 18.8039 18.8608C19.2666 18.4043 19.5608 17.8051 19.641 17.1601Z" fill="#C4C4C4"/>
          </svg>
        </button>
        <button type="button" class="delete-tag-btn" data-id="${uniqueId}">
          <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
           <path d="M7.05273 12.9454L12.9461 7.05371M7.05273 7.05371L12.9461 12.9454" stroke="#C4C4C4" stroke-linecap="round"/>
          </svg>
        </button>
      </span>
      `;
      blogTagFieldset.insertBefore(newTagWrapper, addBlogTagBtn);
          // もしラベルをすぐ編集したいならフォーカスを当てる
      const labelEl = newTagWrapper.querySelector("label[contenteditable]");
      if (labelEl) {
        // キャレットを末尾に持っていきたい場合
        labelEl.focus();
        document.execCommand("selectAll", false, null); // すべて選択
      }
    });
  }

  if (blogTagFieldset) {
    blogTagFieldset.addEventListener("click", (ev) => {
    // (A) 削除ボタンが押されたとき
    const delBtn = ev.target.closest(".delete-tag-btn");
    if (delBtn) {
      // 親のラッパ要素 (div.cms-body_wrapper) を削除する
      // 先に確認ダイアログを出す場合は下記のように
      if (!confirm("このタグを削除してよろしいですか？")) return;
      const wrapper = delBtn.closest(".cms-body_wrapper");
      if (wrapper) wrapper.remove();
      return;
    }

    // (B) 編集ボタンが押されたとき
    const editBtn = ev.target.closest(".edit-tag-btn");
    if (editBtn) {
      // 同じ行の label を contenteditable にしてフォーカス
      const wrapper = editBtn.closest(".cms-body_wrapper");
      if (!wrapper) return;
      const labelEl = wrapper.querySelector("label");
      if (!labelEl) return;

      // 編集を許可
      labelEl.setAttribute("contenteditable", "true");
      labelEl.focus();

      // 全選択（モダンブラウザの場合）
      if (window.getSelection && document.createRange) {
        const range = document.createRange();
        range.selectNodeContents(labelEl);
        const sel = window.getSelection();
        if (sel) {
          sel.removeAllRanges();
          sel.addRange(range);
        }
      } else {
        // 古いブラウザ向け
        document.execCommand("selectAll", false, null);
      }

      // blur で編集完了 → contenteditable を外す
      labelEl.addEventListener(
        "blur",
        () => {
          labelEl.removeAttribute("contenteditable");

          const checkbox = wrapper.querySelector('input[type="checkbox"]');
          if (checkbox) {
            checkbox.value = labelEl.textContent.trim() || "無題タグ";
          }

          // もし空文字になっていたら削除 or 何らかのエラー表示など
          if (labelEl.textContent.trim() === "") {
            if (!confirm("タグ名が空です。削除してよいですか？")) {
              // 元に戻したい場合は適宜処理
              labelEl.textContent = "新しいタグ";
            } else {
              wrapper.remove();
            }
          }
        },
        { once: true }
      );

      return;
    }
  });
}


  // すべてのタブ要素を取得
  const tabItems = document.querySelectorAll('.box_cms-item');
  // すべてのコンテンツ要素を取得
  const panels = document.querySelectorAll('.cms-panel');

  tabItems.forEach((item) => {
    item.addEventListener('click', () => {
      // 1) いったん全タブから active を外し、クリックされたタブだけに active を付ける
      tabItems.forEach(x => x.classList.remove('active'));
      item.classList.add('active');

      // 2) いったんすべてのパネルを非表示にし、対応するIDだけ表示
      panels.forEach(panel => {
        panel.style.display = 'none';
      });

      // 3) クリックされたタブの data-target からIDを取得して、その要素だけ display: block
      const targetId = item.dataset.target;     // 例: "notice-panel"
      const targetPanel = document.getElementById(targetId);
      if (targetPanel) {
        targetPanel.style.display = 'block';
      }
    });
  });
}
const input = document.getElementById('blogThumbnail') as HTMLInputElement;
  const previewImg = document.getElementById('preview') as HTMLImageElement;

  if (input && previewImg) {
    input.addEventListener('change', () => {
      if (input.files && input.files[0]) {
        const file = input.files[0];
        const imageUrl = URL.createObjectURL(file);
        previewImg.src = imageUrl;
        previewImg.style.display = 'block';
      }
    });
  }

  const modal = document.getElementById('deleteConfirmModal');
  const cancelBtn = document.getElementById('cancelDelete');
  const confirmBtn = document.getElementById('confirmDelete') as HTMLButtonElement;
  const projectNameInput = document.getElementById('confirmProjectName') as HTMLInputElement;
  const nameError = document.getElementById('nameError');
  // 削除対象のデータを一時保存
  let targetBlogId: string | null = null;
  let targetProjectId: string | null = null;
  
  // 現在のプロジェクト名を取得
  const currentProjectName = document.querySelector('.modal_project-name')?.textContent || '(No Name)';

  // プロジェクト名の入力チェック
  projectNameInput?.addEventListener('input', () => {
    if (projectNameInput.value === currentProjectName) {
      confirmBtn.disabled = false;
      if (nameError) nameError.textContent = '';
    } else {
      confirmBtn.disabled = true;
      if (nameError) nameError.textContent = 'プロジェクト名が一致しません';
    }
  });

  // 削除ボタンのイベントリスナー
  document.querySelectorAll('.posted_blog-item_btn.delete').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      
      // 削除対象のIDを保存
      targetBlogId = (e.currentTarget as HTMLElement).dataset.blogId || null;
      targetProjectId = new URL(window.location.href).pathname.split('/')[2];
      
      // モーダルを表示
      if (modal) {
        modal.style.display = 'block';
        // 入力フィールドをリセット
        if (projectNameInput) projectNameInput.value = '';
        if (nameError) nameError.textContent = '';
        if (confirmBtn) confirmBtn.disabled = true;
      }
    });
  });
  
  // キャンセルボタンのイベントリスナー
  cancelBtn?.addEventListener('click', () => {
    if (modal) modal.style.display = 'none';
    targetBlogId = null;
    targetProjectId = null;
    if (projectNameInput) projectNameInput.value = '';
    if (nameError) nameError.textContent = '';
    if (confirmBtn) confirmBtn.disabled = true;
  });
  
  // 確認ボタンのイベントリスナーを修正
  confirmBtn?.addEventListener('click', async () => {
    if (!targetProjectId || (!targetBlogId && !targetNoticeId)) return;
    
    try {
      let response;  // responseをここで定義
      // ブログ記事の削除
      if (targetBlogId) {
        response = await fetch(`/api/deleteBlog`, {
          method: 'DELETE',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            projectId: targetProjectId, 
            blogId: targetBlogId 
          })
        });
      }
      // お知らせの削除
      else if (targetNoticeId) {
        response = await fetch(`/api/deleteNotice`, {
          method: 'DELETE',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            projectId: targetProjectId, 
            noticeId: targetNoticeId 
          })
        });
      }

      if (!response) {
        throw new Error('レスポンスが取得できませんでした');
      }

      const result = await response.json();
      if (result.success) {
        window.location.reload();
      } else {
        alert('削除に失敗しました');
      }
    } catch (err) {
      console.error('削除エラー:', err);
      alert('削除に失敗しました');
    } finally {
      if (modal) modal.style.display = 'none';
      targetNoticeId = null;
      targetBlogId = null;
      targetProjectId = null;
    }
  });
  
  // モーダルの外側をクリックしたら閉じる
  window.addEventListener('click', (e) => {
    if (e.target === modal) {
      modal.style.display = 'none';
      targetBlogId = null;
      targetProjectId = null;
      if (projectNameInput) projectNameInput.value = '';
      if (nameError) nameError.textContent = '';
      if (confirmBtn) confirmBtn.disabled = true;
    }
  });

  // お知らせ削除用の変数
  let targetNoticeId: string | null = null;
  
  // お知らせの削除ボタンのイベントリスナー
  document.querySelectorAll('.posted_item_btn.delete').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      
      // 削除対象のIDを保存
      targetNoticeId = (e.currentTarget as HTMLElement).dataset.noticeId || null;
      targetProjectId = new URL(window.location.href).pathname.split('/')[2];
      
      // モーダルを表示
      if (modal) {
        modal.style.display = 'block';
        // 入力フィールドをリセット
        if (projectNameInput) projectNameInput.value = '';
        if (nameError) nameError.textContent = '';
        if (confirmBtn) confirmBtn.disabled = true;
      }
    });
  });

  // キャンセルボタンとモーダル外クリックのリセット処理も修正
  cancelBtn?.addEventListener('click', () => {
    if (modal) modal.style.display = 'none';
    targetNoticeId = null;
    targetBlogId = null;
    targetProjectId = null;
    if (projectNameInput) projectNameInput.value = '';
    if (nameError) nameError.textContent = '';
    if (confirmBtn) confirmBtn.disabled = true;
  });

  window.addEventListener('click', (e) => {
    if (e.target === modal) {
      modal.style.display = 'none';
      targetNoticeId = null;
      targetBlogId = null;
      targetProjectId = null;
      if (projectNameInput) projectNameInput.value = '';
      if (nameError) nameError.textContent = '';
      if (confirmBtn) confirmBtn.disabled = true;
    }
  });

  
  // ブログのサムネイル画像追加部分を修正
  const thumbnailInput = document.getElementById('blogThumbnail') as HTMLInputElement;
  const previewContainer = document.getElementById('thumbnail-preview-container');

  if (thumbnailInput && previewContainer) {
    // 16:9のグレーの枠を作成
    const imagePlaceholder = document.createElement('div');
    imagePlaceholder.className = 'image-placeholder';
    imagePlaceholder.style.width = '280px';
    imagePlaceholder.style.aspectRatio = '16/9';
    imagePlaceholder.style.backgroundColor = '#666';
    imagePlaceholder.style.cursor = 'pointer';
    imagePlaceholder.style.display = 'flex';
    imagePlaceholder.style.alignItems = 'center';
    imagePlaceholder.style.justifyContent = 'center';
    imagePlaceholder.style.borderRadius = '4px';
    imagePlaceholder.innerHTML = '<span style="color:#aaa; font-size:12px;">画像を選択</span>';
    
    // 既存のプレビュー画像があれば削除
    previewContainer.innerHTML = '';
    
    // 枠をコンテナに追加
    previewContainer.appendChild(imagePlaceholder);
    
    // 枠をクリックしたらファイル選択ダイアログを開く
    imagePlaceholder.addEventListener('click', () => {
      thumbnailInput.click();
    });
    
    // ファイルが選択されたらプレビュー表示
    thumbnailInput.addEventListener('change', () => {
      if (thumbnailInput.files && thumbnailInput.files[0]) {
        const file = thumbnailInput.files[0];
        const imageUrl = URL.createObjectURL(file);
        
        // プレビュー画像を表示
        imagePlaceholder.innerHTML = `
          <img src="${imageUrl}" alt="サムネイルプレビュー" 
               style="width:100%; height:100%; object-fit:cover; border-radius:4px;" />
        `;
      }
    });
  }
  
  
  // ブログフォーム送信前に本文データを設定するスクリプト
  document.addEventListener('DOMContentLoaded', () => {
    // ブログフォームを取得
    const blogForm = document.querySelector('form.cms[action="create_blog"]');
    
    if (blogForm) {
      blogForm.addEventListener('submit', function(e) {
        // フォーム送信前に本文データを収集
        const blogElements = document.querySelectorAll('.blog > div');
        let blogContent = '';
        
        // 各要素の内容を収集
        blogElements.forEach(element => {
          blogContent += element.outerHTML;
        });
        
        // デバッグ用にコンソールに出力
        console.log('送信するブログ本文:', blogContent);
        
        // 隠しフィールドに設定
        const blogBodyInput = document.getElementById('blogBodyInput');
        if (blogBodyInput) {
          blogBodyInput.value = blogContent;
        } else {
          console.error('blogBodyInput要素が見つかりません');
        }
      });
    }
  });
  
  document.addEventListener('DOMContentLoaded', () => {
    // ブログフォームを取得
    const blogForm = document.querySelector('form.cms[input[name="action"][value="create_blog"]');
    const blogTextContent = document.getElementById('blogTextContent');
    
    if (blogForm && blogTextContent) {
      blogForm.addEventListener('submit', function(e) {
        // ブログエディタの内容を取得
        const blogContent = document.querySelector('.blog').innerHTML;
        
        // テキストエリアに設定
        blogTextContent.value = blogContent;
        
        console.log('送信するブログ本文:', blogContent);
      });
    }
    
    // ブログ要素追加ボタンのイベントリスナー
    const blogElemButtons = document.querySelectorAll('.blog-elems_elem');
    blogElemButtons.forEach(button => {
      button.addEventListener('click', function(e) {
        e.preventDefault();
        const type = this.getAttribute('data-type');
        addBlogElement(type);
      });
    });
    
    // ブログ要素を追加する関数
    function addBlogElement(type: any) {
      const blogContainer = document.querySelector('.blog');
      if (!blogContainer) return;
      
      let element;
      
      switch(type) {
        case 'heading1':
          element = document.createElement('div');
          element.className = 'blog-heading1';
          element.setAttribute('data-type', 'heading1');
          element.innerHTML = '<div contenteditable="true" placeholder="大見出しを入力"></div>';
          break;
        case 'heading2':
          element = document.createElement('div');
          element.className = 'blog-heading2';
          element.setAttribute('data-type', 'heading2');
          element.innerHTML = '<div contenteditable="true" placeholder="中見出しを入力"></div>';
          break;
        case 'heading3':
          element = document.createElement('div');
          element.className = 'blog-heading3';
          element.setAttribute('data-type', 'heading3');
          element.innerHTML = '<div contenteditable="true" placeholder="小見出しを入力"></div>';
          break;
        case 'text':
          element = document.createElement('div');
          element.className = 'blog-text';
          element.setAttribute('data-type', 'text');
          element.innerHTML = '<div contenteditable="true" placeholder="テキストを入力"></div>';
          break;
        case 'image':
          // 画像アップロード用の要素
          element = document.createElement('div');
          element.className = 'blog-image';
          element.setAttribute('data-type', 'image');
          element.style.width = '100%';
          
          // 16:9の比率を維持するためのラッパー
          const aspectRatioWrapper = document.createElement('div');
          aspectRatioWrapper.style.position = 'relative';
          aspectRatioWrapper.style.width = '100%';
          aspectRatioWrapper.style.paddingTop = '56.25%'; // 16:9の比率（9÷16×100）
          
          // グレーの枠のスタイルを設定
          const imageBox = document.createElement('div');
          imageBox.className = 'image-placeholder';
          imageBox.style.position = 'absolute';
          imageBox.style.top = '0';
          imageBox.style.left = '0';
          imageBox.style.width = '100%';
          imageBox.style.height = '100%';
          imageBox.style.backgroundColor = '#666';
          imageBox.style.display = 'flex';
          imageBox.style.alignItems = 'center';
          imageBox.style.justifyContent = 'center';
          imageBox.style.color = 'white';
          imageBox.style.borderRadius = '4px';
          imageBox.style.cursor = 'pointer';
          imageBox.style.overflow = 'hidden'; // はみ出した部分を隠す
          imageBox.textContent = '画像を選択';
          
          // 隠しフィールドを追加（画像URLを保存するため）
          const hiddenInput = document.createElement('input');
          hiddenInput.type = 'hidden';
          hiddenInput.name = 'blogImageUrl';
          hiddenInput.value = '';
          
          // 要素に追加
          aspectRatioWrapper.appendChild(imageBox);
          element.appendChild(aspectRatioWrapper);
          element.appendChild(hiddenInput);
          
          // 画像ボックスのクリックイベントを設定
          imageBox.addEventListener('click', function() {
            // ファイル選択ダイアログを表示
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'image/*';
            fileInput.style.display = 'none';
            document.body.appendChild(fileInput);
            
            fileInput.addEventListener('change', function() {
              if (fileInput.files && fileInput.files[0]) {
                const file = fileInput.files[0];
                
                // 画像をアップロードするためのFormDataを作成
                const formData = new FormData();
                formData.append('action', 'upload_blog_image');
                formData.append('image', file);
                formData.append('projectId', window.location.pathname.split('/')[2]); // URLからprojectIdを取得
                
                // アップロード中の表示
                imageBox.textContent = 'アップロード中...';
                
                // サーバーに画像をアップロード
                fetch(window.location.pathname, {
                  method: 'POST',
                  body: formData
                })
                .then(response => {
                  if (!response.ok) {
                    throw new Error('画像のアップロードに失敗しました');
                  }
                  return response.json();
                })
                .then(result => {
                  // アップロードされた画像のURLを取得
                  const imageUrl = result.imageUrl;
                  
                  // 隠しフィールドに画像URLを設定
                  hiddenInput.value = imageUrl;
                  
                  // グレーの枠のテキストを削除
                  imageBox.textContent = '';
                  
                  // 画像要素を作成
                  const img = document.createElement('img');
                  img.src = imageUrl;
                  img.alt = 'ブログ画像';
                  img.style.position = 'absolute';
                  img.style.top = '0';
                  img.style.left = '0';
                  img.style.width = '100%';
                  img.style.height = '100%';
                  img.style.aspectRatio = '16 / 9';
                  img.style.objectFit = 'cover'; // 画像をカバーするように設定
                  img.style.borderRadius = '4px';
                  
                  // 画像をグレーの枠に追加
                  imageBox.appendChild(img);
                })
                .catch(error => {
                  console.error('画像アップロードエラー:', error);
                  alert('画像のアップロードに失敗しました: ' + error.message);
                  imageBox.textContent = '画像';
                })
                .finally(() => {
                  // 使用後にファイル入力要素を削除
                  document.body.removeChild(fileInput);
                });
              }
            });
            
            fileInput.click();
          });
          break;
        case 'link':
          element = document.createElement('div');
          element.className = 'blog-link';
          element.setAttribute('data-type', 'link');
          element.innerHTML = `
            <input type="text" placeholder="URLを入力">
            <input type="text" placeholder="リンクテキストを入力">
            <button class="add-link-btn">追加</button>
          `;
          break;
      }
      
      if (element) {
        blogContainer.appendChild(element);
      }
    }
    
    // ブログコンテンツを抽出する関数
    function extractBlogContent() {
      // ブログエディタの内容を取得
      const blogWrapper = document.querySelector('.blog');
      if (!blogWrapper) return '';
      
      // 新しいコンテナを作成
      const contentContainer = document.createElement('div');
      
      // 各コンテンツ要素を処理
      blogWrapper.querySelectorAll('[data-type]').forEach(element => {
        const type = element.getAttribute('data-type');
        
        if (type === 'heading1' || type === 'heading2' || type === 'heading3') {
          // 見出し要素
          const headingText = element.querySelector('div[contenteditable="true"]')?.textContent || '';
          const headingElem = document.createElement(type === 'heading1' ? 'h2' : type === 'heading2' ? 'h3' : 'h4');
          headingElem.textContent = headingText;
          contentContainer.appendChild(headingElem);
        } else if (type === 'text') {
          // テキスト要素
          const text = element.querySelector('div[contenteditable="true"]')?.textContent || '';
          const pElem = document.createElement('p');
          pElem.textContent = text;
          contentContainer.appendChild(pElem);
        } else if (type === 'image') {
          // 画像要素
          const imgSrc = element.querySelector('input[name="blogImageUrl"]')?.value || '';
          if (imgSrc) {
            // 16:9の比率を維持するためのラッパー
            const imgWrapper = document.createElement('div');
            imgWrapper.style.position = 'relative';
            imgWrapper.style.width = '100%';
            imgWrapper.style.paddingTop = '56.25%'; // 16:9の比率
            
            const imgElem = document.createElement('img');
            imgElem.src = imgSrc;
            imgElem.alt = 'ブログ画像';
            imgElem.style.position = 'absolute';
            imgElem.style.top = '0';
            imgElem.style.left = '0';
            imgElem.style.width = '100%';
            imgElem.style.height = '100%';
            imgElem.style.objectFit = 'cover';
            
            imgWrapper.appendChild(imgElem);
            contentContainer.appendChild(imgWrapper);
          }
        } else if (type === 'link') {
          // リンク要素
          const linkText = element.querySelector('a')?.textContent || '';
          const linkHref = element.querySelector('a')?.href || '';
          if (linkHref) {
            const aElem = document.createElement('a');
            aElem.href = linkHref;
            aElem.textContent = linkText;
            contentContainer.appendChild(aElem);
          }
        }
      });
      
      // コンテナのHTMLを返す
      return contentContainer.innerHTML;
    }
    
    // 投稿ボタンと下書き保存ボタンのイベントハンドラを修正
    if (publishButton && blogTextContent) {
      publishButton.addEventListener('click', function(e: { preventDefault: () => void; target: { closest: (arg0: string) => any; }; }) {
        // デフォルトのフォーム送信を防止
        e.preventDefault();
        
        // ブログコンテンツを抽出して設定
        const blogContent = extractBlogContent();
        blogTextContent.value = blogContent;
        
        // タグを収集して保存した後、フォーム送信
        saveSelectedTags(e.target.closest('form'));
        
        console.log('投稿ボタンがクリックされました。ブログ内容:', blogContent);
      });
    }
    
    if (draftButton && blogTextContent) {
      draftButton.addEventListener('click', function(e: { preventDefault: () => void; target: { closest: (arg0: string) => any; }; }) {
        // デフォルトのフォーム送信を防止
        e.preventDefault();
        
        const blogContent = extractBlogContent();
        blogTextContent.value = blogContent;
        
        // タグを収集して保存した後、フォーム送信
        saveSelectedTags(e.target.closest('form'));
        
        console.log('下書き保存ボタンがクリックされました。ブログ内容:', blogContent);
      });
    }
    
    // タグを収集して保存する関数
    function saveSelectedTags(form: any) {
      // 選択されたタグを取得
      const selectedTags = [];
      const tagElements = document.querySelectorAll('.blog-tag.selected');
      tagElements.forEach(tag => {
        selectedTags.push(tag.textContent.trim());
      });
      
      // 新しく追加されたタグを取得
      const customTagInput = document.querySelector('input[name="customTag"]');
      if (customTagInput && customTagInput.value.trim()) {
        const newTag = customTagInput.value.trim();
        selectedTags.push(newTag);
      }
      
      // 選択されたタグをブログ記事用のHidden Inputに保存
      const tagInput = document.querySelector('input[name="blogTags"]');
      if (tagInput) {
        tagInput.value = JSON.stringify(selectedTags);
      }
      
      console.log('ブログ記事に保存するタグ:', selectedTags);
      
      // まずタグ更新APIを呼び出し、成功したらフォームを送信
      updateProjectTags(selectedTags, form);
    }
    
    // プロジェクトタグリストを更新する関数
    function updateProjectTags(tagsToAdd: any[], form: { submit: () => void; } | undefined) {
      // 現在のプロジェクトタグリストを取得
      const projectTagsInput = document.querySelector('input[name="projectTags"]');
      let projectTags = [];
      
      if (projectTagsInput && projectTagsInput.value) {
        try {
          projectTags = JSON.parse(projectTagsInput.value);
        } catch (e) {
          console.error('プロジェクトタグの解析エラー:', e);
          projectTags = []; // エラーの場合は空配列にリセット
        }
      }
      
      // 新しいタグをプロジェクトタグリストに追加
      let hasChanges = false;
      tagsToAdd.forEach((tag: any) => {
        if (tag && !projectTags.includes(tag)) {
          projectTags.push(tag);
          hasChanges = true;
        }
      });
      
      // プロジェクトIDを取得
      const projectId = window.location.pathname.split('/')[2]; // URLからprojectIdを取得
      
      // プロジェクトタグリストを更新
      if (projectTagsInput) {
        projectTagsInput.value = JSON.stringify(projectTags);
      }
      
      // タグに変更がある場合、APIを呼び出してから送信
      if (hasChanges) {
        console.log('APIに送信するデータ:', {
          projectId: projectId,
          allTags: projectTags
        });
        
        // APIエンドポイントにリクエストを送信
        fetch('/api/updateProject', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            projectId: projectId,
            allTags: projectTags
          })
        })
        .then(response => {
          if (!response.ok) {
            throw new Error('プロジェクトタグの更新に失敗しました');
          }
          return response.json();
        })
        .then(result => {
          console.log('プロジェクトタグを更新しました:', result);
          // タグ更新成功後にフォームを送信
          if (form) form.submit();
        })
        .catch(error => {
          console.error('プロジェクトタグ更新エラー:', error);
          // エラーが発生してもフォームは送信する
          if (form) form.submit();
        });
      } else {
        console.log('プロジェクトタグに変更はありません');
        // タグに変更がなければ、そのままフォームを送信
        if (form) form.submit();
      }
    }

    // 新しいタグをプロジェクトに保存する関数
    function saveNewTagToProject(newTag: any) {
      updateProjectTags([newTag]); // 単一のタグを配列として渡す
    }
  });


  // ブログフォームの送信処理を追加
  document.addEventListener('DOMContentLoaded', function() {
    // フォームを取得
    const blogForm = document.querySelector('form.cms');
    
    if (blogForm) {
      // フォーム送信前の処理
      blogForm.addEventListener('submit', function(e) {
        e.preventDefault(); // フォームのデフォルト送信を防止
        
        // ブログ内容を抽出してテキストエリアに設定
        const blogContent = extractBlogContent();
        const blogTextContent = document.getElementById('blogTextContent');
        
        if (blogTextContent && blogContent) {
          blogTextContent.value = blogContent;
          console.log('ブログ内容をテキストエリアに設定:', blogContent);
        }

        
        
        // ------ ここからお知らせのタグ追加ロジックを適用 ------
        
        // 選択されたタグを取得
        const selectedTags = [];
        const tagElements = document.querySelectorAll('.blog-tag.selected');
        tagElements.forEach(tag => {
          selectedTags.push(tag.textContent.trim());
        });
        
        // カスタムタグの処理
        const customTagInput = document.querySelector('input[name="customTag"]');
        if (customTagInput && customTagInput.value.trim()) {
          selectedTags.push(customTagInput.value.trim());
        }
        
        // ブログタグをHidden Inputに設定
        const blogTagsInput = document.querySelector('input[name="blogTags"]');
        if (blogTagsInput) {
          blogTagsInput.value = JSON.stringify(selectedTags);
        }
        
        // プロジェクトタグリストを取得して更新
        const projectTagsInput = document.querySelector('input[name="projectTags"]');
        let projectTags = [];
        
        if (projectTagsInput && projectTagsInput.value) {
          try {
            projectTags = JSON.parse(projectTagsInput.value);
          } catch (e) {
            console.error('プロジェクトタグの解析エラー:', e);
            projectTags = [];
          }
        }
        
        // 新しいタグをプロジェクトタグリストに追加
        let hasChanges = false;
        selectedTags.forEach(tag => {
          if (tag && !projectTags.includes(tag)) {
            projectTags.push(tag);
            hasChanges = true;
          }
        });
        
        // プロジェクトIDを取得
        const projectId = window.location.pathname.split('/')[2];
        
        // お知らせ投稿と同じAPIエンドポイントとパラメータ構造を使用
        if (hasChanges) {
          console.log('お知らせと同じタグ更新APIを呼び出します', {
            projectId: projectId,
            tags: projectTags
          });
          
          fetch('/api/updateProjectTags', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              projectId: projectId,
              tags: projectTags
            })
          })
          .then(response => response.json())
          .then(data => {
            console.log('タグ更新レスポンス:', data);
            // フォームを送信（元のブログ投稿ロジックを維持）
            this.submit();
          })
          .catch(error => {
            console.error('タグ更新失敗:', error);
            // エラーでもフォームは送信
            this.submit();
          });
        } else {
          // タグの変更がなければそのままフォームを送信
          this.submit();
        }
        
        // ------ お知らせのタグ追加ロジック適用ここまで ------
      });
    }
    
    // 投稿ボタンと下書き保存ボタンのイベントリスナー
    const publishButton = document.querySelector('button[name="submitType"][value="publish"]');
    const draftButton = document.querySelector('button[name="submitType"][value="draft"]');
    
    // 投稿ボタンのクリックイベント
    if (publishButton) {
      publishButton.addEventListener('click', function() {
        const blogContent = extractBlogContent();
        const blogTextContent = document.getElementById('blogTextContent');
        
        if (blogTextContent && blogContent) {
          blogTextContent.value = blogContent;
          console.log('公開用ブログ内容:', blogContent);
        }
      });
    }
    
    // 下書き保存ボタンのクリックイベント
    if (draftButton) {
      draftButton.addEventListener('click', function() {
        const blogContent = extractBlogContent();
        const blogTextContent = document.getElementById('blogTextContent');
        
        if (blogTextContent && blogContent) {
          blogTextContent.value = blogContent;
          console.log('下書き用ブログ内容:', blogContent);
        }
      });
    }
    
    // ブログ内容を抽出する関数
    function extractBlogContent() {
      const blogContainer = document.querySelector('.blog');
      if (!blogContainer) return '';
      
      let cleanContent = '';
      
      // 各ブログ要素を処理
      const blogElements = blogContainer.querySelectorAll('[data-type]');
      
      blogElements.forEach(element => {
        const type = element.getAttribute('data-type');
        
        switch (type) {
          case 'heading1':
            const h1Text = element.querySelector('[contenteditable="true"]')?.textContent || '';
            cleanContent += `<h2 contenteditable="true">${h1Text}</h2>`;
            break;
            
          case 'heading2':
            const h2Text = element.querySelector('[contenteditable="true"]')?.textContent || '';
            cleanContent += `<h3 contenteditable="true">${h2Text}</h3>`;
            break;
            
          case 'heading3':
            const h3Text = element.querySelector('[contenteditable="true"]')?.textContent || '';
            cleanContent += `<h4 contenteditable="true">${h3Text}</h4>`;
            break;
            
          case 'text':
            const pText = element.querySelector('[contenteditable="true"]')?.textContent || '';
            cleanContent += `<p contenteditable="true">${pText}</p>`;
            break;
            
          case 'image':
            const imgSrc = element.querySelector('img')?.src || '';
            if (imgSrc) {
              cleanContent += `<div class="blog-image"><img src="${imgSrc}" alt="ブログ画像" style="max-width: 100%; height: auto;"></div>`;
            }
            break;
            
          case 'link':
            const linkElement = element.querySelector('a');
            if (linkElement) {
              const linkUrl = linkElement.href || '';
              const linkText = linkElement.textContent || '';
              if (linkUrl && linkText) {
                cleanContent += `<a href="${linkUrl}">${linkText}</a>`;
              }
            }
            break;
        }
      });
      
      console.log('抽出されたブログ内容:', cleanContent);
      return cleanContent;
    }
  });

  // ブログエディタの初期化
  document.addEventListener('DOMContentLoaded', function() {
    // 必要な要素の取得
    const blogContainer = document.querySelector('.blog');
    const blogElemButtons = document.querySelectorAll('.blog-elems_elem, button[data-type]');
    const blogForm = document.getElementById('blogForm');
    const publishButton = document.querySelector('button[name="submitType"][value="publish"]');
    const draftButton = document.querySelector('button[name="submitType"][value="draft"]');
    
    if (!blogContainer) return;
    
    // ブログ要素追加ボタンのイベントリスナー設定
    blogElemButtons.forEach(button => {
      button.addEventListener('click', function(e) {
        e.preventDefault();
        
        // プレースホルダーがあれば削除
        const placeholder = blogContainer.querySelector('.blog-empty-placeholder');
        if (placeholder) {
          blogContainer.removeChild(placeholder);
        }
        
        // 要素の種類を取得
        const type = this.getAttribute('data-type');
        
        // 要素を追加
        addBlogElement(type, blogContainer);
      });
    });
    
    // フォーム送信処理の設定
    if (blogForm) {
      blogForm.addEventListener('submit', function(e) {
        const blogContent = extractBlogContent();
        const blogTextContent = document.getElementById('blogTextContent');
        
        if (blogTextContent && blogContent) {
          blogTextContent.value = blogContent;
          console.log('ブログ内容をテキストエリアに設定:', blogContent);
        }
      });
    }
    
    // 投稿ボタンのクリックイベント
    if (publishButton) {
      publishButton.addEventListener('click', function() {
        const blogContent = extractBlogContent();
        const blogTextContent = document.getElementById('blogTextContent');
        
        if (blogTextContent && blogContent) {
          blogTextContent.value = blogContent;
          console.log('公開用ブログ内容:', blogContent);
        }
      });
    }
    
    // 下書き保存ボタンのクリックイベント
    if (draftButton) {
      draftButton.addEventListener('click', function() {
        const blogContent = extractBlogContent();
        const blogTextContent = document.getElementById('blogTextContent');
        
        if (blogTextContent && blogContent) {
          blogTextContent.value = blogContent;
          console.log('下書き用ブログ内容:', blogContent);
        }
      });
    }
    
    // 空のブログにプレースホルダーを追加
    initializeEmptyBlog();
    
    /**
     * ブログが空の場合にプレースホルダーを追加する関数
     */
    function initializeEmptyBlog() {
      // コンテンツがあるかチェック
      const hasContent = Array.from(blogContainer.children).some(child => {
        return child.nodeType === Node.ELEMENT_NODE && 
               !child.classList.contains('blog-empty-placeholder');
      });
      
      // コンテンツがない場合、プレースホルダーを追加
      if (!hasContent) {
        console.log('プレースホルダーを追加します');
        
        // プレースホルダー要素を作成
        const placeholder = document.createElement('div');
        placeholder.className = 'blog-empty-placeholder';
        placeholder.style.padding = '30px 20px';
        placeholder.style.cursor = 'pointer';
        placeholder.style.backgroundColor = '#2b2b32';
        placeholder.style.borderRadius = '8px';
        placeholder.style.textAlign = 'center';
        placeholder.style.color = '#6c757d';
        placeholder.style.border = '2px dashed #3c3c40';
        placeholder.style.margin = '20px 0';
        
        placeholder.innerHTML = `
          <div style="display: flex; justify-content: center; margin-bottom: 16px;">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#808080" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
              <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
            </svg>
          </div>
          <h3 style="margin-bottom: 8px; font-size: 12px; color: #808080;">ブログ本文を作成しましょう</h3>
          <p style="font-size: 12px; line-height: 1.5; color: #808080;">上部のボタンから見出し、テキスト、画像などの要素を追加して、魅力的なブログ記事を作成しましょう。</p>
          
          <div style="display: flex; justify-content: center; gap: 16px; margin-top: 24px;">
            <div class="template-card" style="background-color: #3c3c44; padding: 12px; border-radius: 6px; cursor: pointer; min-width: 100px; transition: transform 0.2s;">
              <div style="font-weight: bold; color: #f5f5f5; margin-bottom: 4px;">テンプレートA</div>
              <div style="font-size: 10px; color: #aaa;">基本的な記事構成</div>
            </div>
            <div class="template-card" style="background-color: #3c3c44; padding: 12px; border-radius: 6px; cursor: pointer; min-width: 100px; transition: transform 0.2s;">
              <div style="font-weight: bold; color: #f5f5f5; margin-bottom: 4px;">テンプレートB</div>
              <div style="font-size: 10px; color: #aaa;">画像メイン構成</div>
            </div>
            <div class="template-card" style="background-color: #3c3c44; padding: 12px; border-radius: 6px; cursor: pointer; min-width: 100px; transition: transform 0.2s;">
              <div style="font-weight: bold; color: #f5f5f5; margin-bottom: 4px;">テンプレートC</div>
              <div style="font-size: 10px; color: #aaa;">リスト形式構成</div>
            </div>
          </div>
        `;
        
        // プレースホルダーをコンテナに追加
        blogContainer.appendChild(placeholder);
        console.log('プレースホルダーが追加されました');
        
        // テンプレートカードのクリックイベントを設定
        const templateCards = placeholder.querySelectorAll('.template-card');
        
        // 全てのカードに共通のホバーエフェクトを追加
        templateCards.forEach(card => {
          card.addEventListener('mouseenter', function() {
            this.style.transform = 'translateY(-4px)';
          });
          card.addEventListener('mouseleave', function() {
            this.style.transform = 'translateY(0)';
          });
        });

        // テンプレートAのクリックイベント
        templateCards[0].addEventListener('mouseenter', function() {
          this.style.transform = 'translateY(-4px)';
        });
        templateCards[0].addEventListener('mouseleave', function() {
          this.style.transform = 'translateY(0)';
        });
        templateCards[0].addEventListener('click', function() {
          // プレースホルダーを削除
          blogContainer.removeChild(placeholder);
          
          // まず通知バナーを追加
          const notification = createTemplateNotification('テンプレートA', '基本的な記事構成');
          blogContainer.appendChild(notification);
          
          // getSnippetHTML関数を使ってHTMLを取得し追加
          addTemplateContent(['heading1', 'text', 'heading2', 'text'], blogContainer);
        });
        
        // テンプレートBのクリックイベント
        templateCards[1].addEventListener('mouseenter', function() {
          this.style.transform = 'translateY(-4px)';
        });
        templateCards[1].addEventListener('mouseleave', function() {
          this.style.transform = 'translateY(0)';
        });
        templateCards[1].addEventListener('click', function() {
          // プレースホルダーを削除
          blogContainer.removeChild(placeholder);
          
          // まず通知バナーを追加
          const notification = createTemplateNotification('テンプレートB', '画像メイン構成');
          blogContainer.appendChild(notification);
          
          // getSnippetHTML関数を使ってHTMLを取得し追加
          addTemplateContent(['heading1', 'text', 'image', 'heading2', 'text'], blogContainer);
        });
        
        // テンプレートCのクリックイベント
        templateCards[2].addEventListener('mouseenter', function() {
          this.style.transform = 'translateY(-4px)';
        });
        templateCards[2].addEventListener('mouseleave', function() {
          this.style.transform = 'translateY(0)';
        });
        templateCards[2].addEventListener('click', function() {
          // プレースホルダーを削除
          blogContainer.removeChild(placeholder);
          
          // まず通知バナーを追加
          const notification = createTemplateNotification('テンプレートC', 'リスト形式構成');
          blogContainer.appendChild(notification);
          
          // getSnippetHTML関数を使ってHTMLを取得し追加
          addTemplateContent(['heading1', 'text', 'heading3', 'text', 'heading3', 'text'], blogContainer);
        });
        
        // テンプレート通知要素を作成する関数
        function createTemplateNotification(templateName: string, templateDesc: string) {
          const notification = document.createElement('div');
          notification.className = 'template-notification';
          notification.style.backgroundColor = '#373740';
          notification.style.borderRadius = '6px';
          notification.style.padding = '10px 16px';
          notification.style.marginBottom = '16px';
          notification.style.display = 'flex';
          notification.style.alignItems = 'center';
          notification.style.justifyContent = 'space-between';
          
          // 通知内容
          notification.innerHTML = `
            <div style="display: flex; align-items: center; gap: 12px;">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#64B5F6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
              </svg>
              <div>
                <div style="font-size: 13px; color: #e0e0e0; font-weight: 500;">${templateName}を適用しました</div>
                <div style="font-size: 11px; color: #a0a0a0;">${templateDesc}</div>
              </div>
            </div>
            <button class="template-cancel-btn" style="background: transparent; border: 1px solid #505057; border-radius: 4px; padding: 5px 10px; color: #c0c0c0; cursor: pointer; font-size: 12px; transition: all 0.2s;">
              キャンセル
            </button>
          `;
          
          // キャンセルボタンのイベント処理
          const cancelBtn = notification.querySelector('.template-cancel-btn');
          cancelBtn.addEventListener('mouseenter', function() {
            this.style.backgroundColor = '#ff5252';
            this.style.borderColor = '#ff5252';
            this.style.color = 'white';
          });
          
          cancelBtn.addEventListener('mouseleave', function() {
            this.style.backgroundColor = 'transparent';
            this.style.borderColor = '#505057';
            this.style.color = '#c0c0c0';
          });
          
          cancelBtn.addEventListener('click', function() {
            // blogContainerの内容をすべて削除
            while (blogContainer.firstChild) {
              blogContainer.removeChild(blogContainer.firstChild);
            }
            
            // プレースホルダーを再作成して追加
            const newPlaceholder = createPlaceholder();
            blogContainer.appendChild(newPlaceholder);
            
            // プレースホルダーの初期化（テンプレートカードのイベント設定等）
            setupPlaceholderEvents(newPlaceholder);
          });
          
          return notification;
        }
        
        // テンプレートの内容を追加する関数
        function addTemplateContent(types: any[], container: Element | null) {
          types.forEach((type: any) => {
            const snippet = getSnippetHTML(type);
            if (!snippet) return;
            
            // DOMノードとして追加
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = snippet.trim();
            const newBlock = tempDiv.firstElementChild;
            
            if (newBlock) {
              container.appendChild(newBlock);
              
              // 要素の初期化
              const editable = newBlock.querySelector('[contenteditable="true"]');
              if (editable) {
                initializeEditableElement(editable, newBlock);
              }
              
              const deleteBtn = newBlock.querySelector('.blog_action-btn');
              if (deleteBtn) {
                initializeDeleteButton(deleteBtn, newBlock);
              }
            }
          });
        }
        
        // プレースホルダーを作成する関数
        function createPlaceholder() {
          const placeholder = document.createElement('div');
          placeholder.className = 'blog-empty-placeholder';
          placeholder.style.padding = '30px 20px';
          placeholder.style.cursor = 'pointer';
          placeholder.style.backgroundColor = '#2b2b32';
          placeholder.style.borderRadius = '8px';
          placeholder.style.textAlign = 'center';
          placeholder.style.color = '#6c757d';
          placeholder.style.border = '2px dashed #3c3c40';
          placeholder.style.margin = '20px 0';
          
          placeholder.innerHTML = `
            <div style="display: flex; justify-content: center; margin-bottom: 16px;">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#808080" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
              </svg>
            </div>
            <h3 style="margin-bottom: 8px; font-size: 12px; color: #808080;">ブログ本文を作成しましょう</h3>
            <p style="font-size: 12px; line-height: 1.5; color: #808080;">上部のボタンから見出し、テキスト、画像などの要素を追加して、魅力的なブログ記事を作成しましょう。</p>
            
            <div style="display: flex; justify-content: center; gap: 16px; margin-top: 24px;">
              <div class="template-card" style="background-color: #3c3c44; padding: 12px; border-radius: 6px; cursor: pointer; min-width: 100px; transition: transform 0.2s;">
                <div style="font-weight: bold; color: #f5f5f5; margin-bottom: 4px;">テンプレートA</div>
                <div style="font-size: 10px; color: #aaa;">基本的な記事構成</div>
              </div>
              <div class="template-card" style="background-color: #3c3c44; padding: 12px; border-radius: 6px; cursor: pointer; min-width: 100px; transition: transform 0.2s;">
                <div style="font-weight: bold; color: #f5f5f5; margin-bottom: 4px;">テンプレートB</div>
                <div style="font-size: 10px; color: #aaa;">画像メイン構成</div>
              </div>
              <div class="template-card" style="background-color: #3c3c44; padding: 12px; border-radius: 6px; cursor: pointer; min-width: 100px; transition: transform 0.2s;">
                <div style="font-weight: bold; color: #f5f5f5; margin-bottom: 4px;">テンプレートC</div>
                <div style="font-size: 10px; color: #aaa;">リスト形式構成</div>
              </div>
            </div>
          `;
          
          return placeholder;
        }
        
        // プレースホルダーのイベントを設定する関数
        function setupPlaceholderEvents(placeholder: HTMLDivElement) {
          const templateCards = placeholder.querySelectorAll('.template-card');
          
          // 各テンプレートカードのマウスイベントを設定
          templateCards.forEach((card: { addEventListener: (arg0: string, arg1: { (): void; (): void; }) => void; }, index: any) => {
            card.addEventListener('mouseenter', function() {
              this.style.transform = 'translateY(-4px)';
            });
            card.addEventListener('mouseleave', function() {
              this.style.transform = 'translateY(0)';
            });
          });
          
          // テンプレートAのクリックイベント
          templateCards[0].addEventListener('click', function() {
            blogContainer.removeChild(placeholder);
            
            // まず通知バナーを追加
            const notification = createTemplateNotification('テンプレートA', '基本的な記事構成');
            blogContainer.appendChild(notification);
            
            // getSnippetHTML関数を使ってHTMLを取得し追加
            addTemplateContent(['heading1', 'text', 'heading2', 'text'], blogContainer);
          });
          
          // テンプレートBのクリックイベント
          templateCards[1].addEventListener('click', function() {
            blogContainer.removeChild(placeholder);
            
            // まず通知バナーを追加
            const notification = createTemplateNotification('テンプレートB', '画像メイン構成');
            blogContainer.appendChild(notification);
            
            // getSnippetHTML関数を使ってHTMLを取得し追加
            addTemplateContent(['heading1', 'text', 'image', 'heading2', 'text'], blogContainer);
          });
          
          // テンプレートCのクリックイベント
          templateCards[2].addEventListener('click', function() {
            blogContainer.removeChild(placeholder);
            
            // まず通知バナーを追加
            const notification = createTemplateNotification('テンプレートC', 'リスト形式構成');
            blogContainer.appendChild(notification);
            
            // getSnippetHTML関数を使ってHTMLを取得し追加
            addTemplateContent(['heading1', 'text', 'heading3', 'text', 'heading3', 'text'], blogContainer);
          });
        }
        
        // ヘルパー関数
        function initializeEditableElement(editable: Element, block: Element) {
          editable.addEventListener('blur', () => {
            if (editable.textContent.trim() === '') {
              block.remove();
            }
          });
        }
        
        function initializeDeleteButton(btn: Element, block: Element) {
          btn.addEventListener('click', () => {
            // ブロックを削除
            block.remove();
            
            // ブログコンテナを取得
            const blogContainer = document.querySelector('.blog');
            if (blogContainer) {
              // ブログコンテナ内の要素をカウント（通知バナーを除く）
              const contentElements = blogContainer.querySelectorAll('[data-type]');
              
              // コンテナが空になったらプレースホルダーを表示
              if (contentElements.length === 0) {
                console.log('ブログが空になりました - プレースホルダーを表示します');
                // プレースホルダーを作成して追加
                const newPlaceholder = createPlaceholder();
                blogContainer.appendChild(newPlaceholder);
                // プレースホルダーの初期化（テンプレートカードのイベント設定等）
                setupPlaceholderEvents(newPlaceholder);
              }
            }
          });
        }
      }
    }
  });

  // DOMContentLoadedイベントにBlog空判定の機能を追加
  document.addEventListener("DOMContentLoaded", function() {
    // ブログコンテナを取得
    const blogContainer = document.querySelector('.blog');
    
    if (blogContainer) {
      console.log('ブログコンテナを監視します');
      
      // MutationObserverを作成 - ブログコンテナの子要素の変更を監視
      const observer = new MutationObserver(function(mutations) {
        // 子要素が削除されたかどうかの判定
        let needsCheck = false;
        
        mutations.forEach(mutation => {
          if (mutation.type === 'childList' && mutation.removedNodes.length > 0) {
            needsCheck = true;
          }
        });
        
        // 子要素が削除された場合のみ確認
        if (needsCheck) {
          if (blogContainer.children.length === 0) {
          console.log('ブログが空になりました - プレースホルダーを表示します');
          
          // 元々のコードと同じ方法でプレースホルダーを生成・追加（ここが重要）
          const placeholder = createPlaceholder();
          blogContainer.appendChild(placeholder);
          console.log('プレースホルダーが追加されました');
          
          // 元のコードと同様にイベントをバインド
          setupPlaceholderEvents(placeholder);
        }
      }});
      
      // 監視を開始 - 子要素の追加・削除を監視
      observer.observe(blogContainer, { childList: true });
    }
    
  });

  // プレースホルダーを作成する関数 - 既存の関数を活用、なければ定義
  function createPlaceholder() {
    const placeholder = document.createElement('div');
    placeholder.className = 'blog-empty-placeholder';
    placeholder.style.padding = '30px 20px';
    placeholder.style.cursor = 'pointer';
    placeholder.style.backgroundColor = '#2b2b32';
    placeholder.style.borderRadius = '8px';
    placeholder.style.textAlign = 'center';
    placeholder.style.color = '#6c757d';
    placeholder.style.border = '2px dashed #3c3c40';
    placeholder.style.margin = '20px 0';
    
    placeholder.innerHTML = `
      <div style="display: flex; justify-content: center; margin-bottom: 16px;">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#808080" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
          <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
        </svg>
      </div>
      <h3 style="margin-bottom: 8px; font-size: 12px; color: #808080;">ブログ本文を作成しましょう</h3>
      <p style="font-size: 12px; line-height: 1.5; color: #808080;">上部のボタンから見出し、テキスト、画像などの要素を追加して、魅力的なブログ記事を作成しましょう。</p>
      
      <div style="display: flex; justify-content: center; gap: 16px; margin-top: 24px;">
        <div class="template-card" style="background-color: #3c3c44; padding: 12px; border-radius: 6px; cursor: pointer; min-width: 100px; transition: transform 0.2s;">
          <div style="font-weight: bold; color: #f5f5f5; margin-bottom: 4px;">テンプレートA</div>
          <div style="font-size: 10px; color: #aaa;">基本的な記事構成</div>
        </div>
        <div class="template-card" style="background-color: #3c3c44; padding: 12px; border-radius: 6px; cursor: pointer; min-width: 100px; transition: transform 0.2s;">
          <div style="font-weight: bold; color: #f5f5f5; margin-bottom: 4px;">テンプレートB</div>
          <div style="font-size: 10px; color: #aaa;">画像メイン構成</div>
        </div>
        <div class="template-card" style="background-color: #3c3c44; padding: 12px; border-radius: 6px; cursor: pointer; min-width: 100px; transition: transform 0.2s;">
          <div style="font-weight: bold; color: #f5f5f5; margin-bottom: 4px;">テンプレートC</div>
          <div style="font-size: 10px; color: #aaa;">リスト形式構成</div>
        </div>
      </div>
    `;
    
    return placeholder;
  }

  // プレースホルダーのイベントを設定する関数 - 既存の関数を活用、なければ定義
  function setupPlaceholderEvents(placeholder: HTMLDivElement) {
    const templateCards = placeholder.querySelectorAll('.template-card');
    const blogContainer = document.querySelector('.blog');

    // ヘルパー関数
    function initializeEditableElement(editable: Element, block: Element) {
      editable.addEventListener('blur', () => {
        if (editable.textContent.trim() === '') {
          block.remove();
        }
      });
    }

    function initializeDeleteButton(btn: Element, block: Element) {
      btn.addEventListener('click', () => {
        // ブロックを削除
        block.remove();
        
        // ブログコンテナを取得
        const blogContainer = document.querySelector('.blog');
        if (blogContainer) {
          // ブログコンテナ内の要素をカウント（通知バナーを除く）
          const contentElements = blogContainer.querySelectorAll('[data-type]');
          
          // コンテナが空になったらプレースホルダーを表示
          if (contentElements.length === 0) {
            console.log('ブログが空になりました - プレースホルダーを表示します');
            // プレースホルダーを作成して追加
            const newPlaceholder = createPlaceholder();
            blogContainer.appendChild(newPlaceholder);
            // プレースホルダーの初期化（テンプレートカードのイベント設定等）
            setupPlaceholderEvents(newPlaceholder);
          }
        }
      });
    }

    // テンプレート通知要素を作成する関数
    function createTemplateNotification(templateName: string, templateDesc: string) {
      const notification = document.createElement('div');
      notification.className = 'template-notification';
      notification.style.backgroundColor = '#373740';
      notification.style.borderRadius = '6px';
      notification.style.padding = '10px 16px';
      notification.style.marginBottom = '16px';
      notification.style.display = 'flex';
      notification.style.alignItems = 'center';
      notification.style.justifyContent = 'space-between';
          
      // 通知内容
      notification.innerHTML = `
        <div style="display: flex; align-items: center; gap: 12px;">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#64B5F6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
            <polyline points="14 2 14 8 20 8"></polyline>
            <line x1="16" y1="13" x2="8" y2="13"></line>
            <line x1="16" y1="17" x2="8" y2="17"></line>
            <polyline points="10 9 9 9 8 9"></polyline>
          </svg>
          <div>
            <div style="font-size: 13px; color: #e0e0e0; font-weight: 500;">${templateName}を適用しました</div>
            <div style="font-size: 11px; color: #a0a0a0;">${templateDesc}</div>
          </div>
        </div>
        <button class="template-cancel-btn" style="background: transparent; border: 1px solid #505057; border-radius: 4px; padding: 5px 10px; color: #c0c0c0; cursor: pointer; font-size: 12px; transition: all 0.2s;">
          キャンセル
        </button>
      `;
      
      // キャンセルボタンのイベント処理
      const cancelBtn = notification.querySelector('.template-cancel-btn');
      cancelBtn.addEventListener('mouseenter', function() {
        this.style.backgroundColor = '#ff5252';
        this.style.borderColor = '#ff5252';
        this.style.color = 'white';
      });
      
      cancelBtn.addEventListener('mouseleave', function() {
        this.style.backgroundColor = 'transparent';
        this.style.borderColor = '#505057';
        this.style.color = '#c0c0c0';
      });
      
      cancelBtn.addEventListener('click', function() {
        // blogContainerの内容をすべて削除
        while (blogContainer.firstChild) {
          blogContainer.removeChild(blogContainer.firstChild);
        }
        
        // プレースホルダーを再作成して追加
        const newPlaceholder = createPlaceholder();
        blogContainer.appendChild(newPlaceholder);
        
        // プレースホルダーの初期化（テンプレートカードのイベント設定等）
        setupPlaceholderEvents(newPlaceholder);
      });
      
      return notification;
    }
    
    // テンプレートの内容を追加する関数
    function addTemplateContent(types: any[], container: Element) {
      types.forEach((type: any) => {
        const snippet = getSnippetHTML(type);
        if (!snippet) return;
        
        // DOMノードとして追加
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = snippet.trim();
        const newBlock = tempDiv.firstElementChild;
        
        if (newBlock) {
          container.appendChild(newBlock);
          
          // 要素の初期化
          const editable = newBlock.querySelector('[contenteditable="true"]');
          if (editable) {
            initializeEditableElement(editable, newBlock);
          }
          
          const deleteBtn = newBlock.querySelector('.blog_action-btn');
          if (deleteBtn) {
            initializeDeleteButton(deleteBtn, newBlock);
          }
        }
       });
    }
    
    // 各テンプレートカードのマウスイベントを設定
    templateCards.forEach((card: { addEventListener: (arg0: string, arg1: { (): void; (): void; }) => void; }, index: any) => {
      card.addEventListener('mouseenter', function() {
        this.style.transform = 'translateY(-4px)';
      });
      card.addEventListener('mouseleave', function() {
        this.style.transform = 'translateY(0)';
      });
    });
    
    // テンプレートAのクリックイベント
    templateCards[0]?.addEventListener('click', function() {
      if (blogContainer && placeholder) {
        blogContainer.removeChild(placeholder);
        
        // まず通知バナーを追加
        const notification = createTemplateNotification('テンプレートA', '基本的な記事構成');
        blogContainer.appendChild(notification);
        
        // getSnippetHTML関数を使ってHTMLを取得し追加
        addTemplateContent(['heading1', 'text', 'heading2', 'text'], blogContainer);
      }
    });
    
    // テンプレートBのクリックイベント
    templateCards[1]?.addEventListener('click', function() {
      if (blogContainer && placeholder) {
        blogContainer.removeChild(placeholder);
        
        // まず通知バナーを追加
        const notification = createTemplateNotification('テンプレートB', '画像メイン構成');
        blogContainer.appendChild(notification);
        
        // getSnippetHTML関数を使ってHTMLを取得し追加
        addTemplateContent(['heading1', 'text', 'image', 'heading2', 'text'], blogContainer);
      }
    });
    
    // テンプレートCのクリックイベント
    templateCards[2]?.addEventListener('click', function() {
      if (blogContainer && placeholder) {
        blogContainer.removeChild(placeholder);
        
        // まず通知バナーを追加
        const notification = createTemplateNotification('テンプレートC', 'リスト形式構成');
        blogContainer.appendChild(notification);
        
        // getSnippetHTML関数を使ってHTMLを取得し追加
        addTemplateContent(['heading1', 'text', 'heading3', 'text', 'heading3', 'text'], blogContainer);
      }
    });
  }

  // 公開/下書き切り替え用のJavaScriptを追加
  // 既存のスクリプト内に追加します

  // ブログとお知らせの公開/下書き切り替え機能
  document.addEventListener('DOMContentLoaded', () => {
    // お知らせの公開/下書き切り替え
    // セレクタを修正
    const noticeStatusButtons = document.querySelectorAll('.posted .subject_wrapper .status-btn');
    const noticeItems = document.querySelectorAll('.posted_item');
    
    if (noticeStatusButtons.length >= 2) {
      // 公開ボタン
      noticeStatusButtons[0].addEventListener('click', () => {
        noticeStatusButtons.forEach(btn => btn.classList.remove('active'));
        noticeStatusButtons[0].classList.add('active');
        
        // 公開状態のアイテムだけを表示
        noticeItems.forEach(item => {
          const status = item.getAttribute('data-status');
          if (status === 'public') {
            item.style.display = 'flex';
          } else {
            item.style.display = 'none';
          }
        });
      });
      
      // 下書きボタン
      noticeStatusButtons[1].addEventListener('click', () => {
        noticeStatusButtons.forEach(btn => btn.classList.remove('active'));
        noticeStatusButtons[1].classList.add('active');
        
        // 下書き状態のアイテムだけを表示
        noticeItems.forEach(item => {
          const status = item.getAttribute('data-status');
          if (status === 'draft') {
            item.style.display = 'flex';
          } else {
            item.style.display = 'none';
          }
        });
      });
    }
    
    // ブログの公開/下書き切り替え
    // セレクタを修正
    const blogStatusButtons = document.querySelectorAll('.posted-blog .subject_wrapper .status-btn');
    const blogItems = document.querySelectorAll('.posted_blog-item');
    
    // デバッグ用ログ
    console.log('ブログステータスボタン数:', blogStatusButtons.length);
    console.log('ブログアイテム数:', blogItems.length);
    
    if (blogStatusButtons.length >= 2) {
      // 公開ボタン
      blogStatusButtons[0].addEventListener('click', () => {
        console.log('公開ボタンがクリックされました');
        blogStatusButtons.forEach(btn => btn.classList.remove('active'));
        blogStatusButtons[0].classList.add('active');
        
        // 公開状態のアイテムだけを表示
        blogItems.forEach(item => {
          const status = item.getAttribute('data-status');
          console.log('アイテムステータス:', status);
          if (status === 'public') {
            item.style.display = 'block';
          } else {
            item.style.display = 'none';
          }
        });
      });
      
      // 下書きボタン
      blogStatusButtons[1].addEventListener('click', () => {
        console.log('下書きボタンがクリックされました');
        blogStatusButtons.forEach(btn => btn.classList.remove('active'));
        blogStatusButtons[1].classList.add('active');
        
        // 下書き状態のアイテムだけを表示
        blogItems.forEach(item => {
          const status = item.getAttribute('data-status');
          if (status === 'draft') {
            item.style.display = 'block';
          } else {
            item.style.display = 'none';
          }
        });
      });
    }
  });

  // 公開/下書き切り替え機能の修正
  // DOMContentLoadedイベントを削除し、直接実行するコードに変更

  // お知らせの公開/下書き切り替え
  const noticeStatusButtons = document.querySelectorAll('.posted .subject_wrapper button');
  const noticeItems = document.querySelectorAll('.posted_item');

  console.log('お知らせステータスボタン数:', noticeStatusButtons.length);
  console.log('お知らせアイテム数:', noticeItems.length);

  if (noticeStatusButtons.length >= 2) {
    // 公開ボタン
    noticeStatusButtons[0].addEventListener('click', () => {
      console.log('お知らせ公開ボタンがクリックされました');
      noticeStatusButtons.forEach(btn => btn.classList.remove('active'));
      noticeStatusButtons[0].classList.add('active');
      
      // 公開状態のアイテムだけを表示
      noticeItems.forEach(item => {
        const status = item.getAttribute('data-status');
        console.log('お知らせステータス:', status);
        if (status === 'public') {
          item.style.display = 'flex';
        } else {
          item.style.display = 'none';
        }
      });
    });
    
    // 下書きボタン
    noticeStatusButtons[1].addEventListener('click', () => {
      console.log('お知らせ下書きボタンがクリックされました');
      noticeStatusButtons.forEach(btn => btn.classList.remove('active'));
      noticeStatusButtons[1].classList.add('active');
      
      // 下書き状態のアイテムだけを表示
      noticeItems.forEach(item => {
        const status = item.getAttribute('data-status');
        if (status === 'draft') {
          item.style.display = 'flex';
        } else {
          item.style.display = 'none';
        }
      });
    });
  }

  // ブログの公開/下書き切り替え
  const blogStatusButtons = document.querySelectorAll('.posted-blog .subject_wrapper button');
  const blogItems = document.querySelectorAll('.posted_blog-item');

  // デバッグ用ログ
  console.log('ブログステータスボタン数:', blogStatusButtons.length);
  console.log('ブログアイテム数:', blogItems.length);

  if (blogStatusButtons.length >= 2) {
    // 公開ボタン
    blogStatusButtons[0].addEventListener('click', () => {
      console.log('ブログ公開ボタンがクリックされました');
      blogStatusButtons.forEach(btn => btn.classList.remove('active'));
      blogStatusButtons[0].classList.add('active');
      
      // 公開状態のアイテムだけを表示
      blogItems.forEach(item => {
        const status = item.getAttribute('data-status');
        console.log('ブログアイテムステータス:', status);
        if (status === 'public') {
          item.style.display = 'block';
        } else {
          item.style.display = 'none';
        }
      });
    });
    
    // 下書きボタン
    blogStatusButtons[1].addEventListener('click', () => {
      console.log('ブログ下書きボタンがクリックされました');
      blogStatusButtons.forEach(btn => btn.classList.remove('active'));
      blogStatusButtons[1].classList.add('active');
      
      // 下書き状態のアイテムだけを表示
      blogItems.forEach(item => {
        const status = item.getAttribute('data-status');
        if (status === 'draft') {
          item.style.display = 'block';
        } else {
          item.style.display = 'none';
        }
      });
    });
  }

  // 重複しているコードを削除し、一つにまとめます
  // DOMContentLoadedイベントリスナーも削除します

  // 既存のコードをすべて削除して、以下のコードに置き換えてください

  // お知らせの公開/下書き切り替え
  window.addEventListener('load', () => {
    // お知らせの切り替え
    const noticePublicBtn = document.querySelector('.posted .subject_wrapper button:nth-child(1)');
    const noticeDraftBtn = document.querySelector('.posted .subject_wrapper button:nth-child(2)');
    const noticeItems = document.querySelectorAll('.posted_item');

    console.log('お知らせボタン:', noticePublicBtn, noticeDraftBtn);
    console.log('お知らせアイテム数:', noticeItems.length);

    if (noticePublicBtn && noticeDraftBtn) {
      // 公開ボタン
      noticePublicBtn.addEventListener('click', () => {
        console.log('お知らせ公開ボタンがクリックされました');
        noticePublicBtn.classList.add('active');
        noticeDraftBtn.classList.remove('active');
        
        // 公開状態のアイテムだけを表示
        noticeItems.forEach(item => {
          const status = item.getAttribute('data-status');
          console.log('お知らせステータス:', status);
          if (status === 'public') {
            item.style.display = 'flex';
          } else {
            item.style.display = 'none';
          }
        });
      });
      
      // 下書きボタン
      noticeDraftBtn.addEventListener('click', () => {
        console.log('お知らせ下書きボタンがクリックされました');
        noticeDraftBtn.classList.add('active');
        noticePublicBtn.classList.remove('active');
        
        // 下書き状態のアイテムだけを表示
        noticeItems.forEach(item => {
          const status = item.getAttribute('data-status');
          if (status === 'draft') {
            item.style.display = 'flex';
          } else {
            item.style.display = 'none';
          }
        });
      });
    }

    // ブログの切り替え
    const blogPublicBtn = document.querySelector('.posted-blog .subject_wrapper button:nth-child(1)');
    const blogDraftBtn = document.querySelector('.posted-blog .subject_wrapper button:nth-child(2)');
    const blogItems = document.querySelectorAll('.posted_blog-item');

    console.log('ブログボタン:', blogPublicBtn, blogDraftBtn);
    console.log('ブログアイテム数:', blogItems.length);

    if (blogPublicBtn && blogDraftBtn) {
      // 公開ボタン
      blogPublicBtn.addEventListener('click', () => {
        console.log('ブログ公開ボタンがクリックされました');
        blogPublicBtn.classList.add('active');
        blogDraftBtn.classList.remove('active');
        
        // 公開状態のアイテムだけを表示
        blogItems.forEach(item => {
          const status = item.getAttribute('data-status');
          console.log('ブログアイテムステータス:', status);
          if (status === 'public') {
            item.style.display = 'block';
          } else {
            item.style.display = 'none';
          }
        });
      });
      
      // 下書きボタン
      blogDraftBtn.addEventListener('click', () => {
        console.log('ブログ下書きボタンがクリックされました');
        blogDraftBtn.classList.add('active');
        blogPublicBtn.classList.remove('active');
        
        // 下書き状態のアイテムだけを表示
        blogItems.forEach(item => {
          const status = item.getAttribute('data-status');
          if (status === 'draft') {
            item.style.display = 'block';
          } else {
            item.style.display = 'none';
          }
        });
      });
    }
  });

  // 重複しているコードをすべて削除し、以下のコードだけを残します

  // 公開/下書き切り替え機能
  window.addEventListener('load', () => {
    // お知らせの切り替え - IDを使用
    const noticeStatusWrapper = document.getElementById('notice-status-wrapper');
    if (noticeStatusWrapper) {
      const noticePublicBtn = noticeStatusWrapper.querySelector('button:nth-child(1)');
      const noticeDraftBtn = noticeStatusWrapper.querySelector('button:nth-child(2)');
      const noticeItems = document.querySelectorAll('.posted_item');

      console.log('お知らせボタン:', noticePublicBtn, noticeDraftBtn);
      console.log('お知らせアイテム数:', noticeItems.length);

      if (noticePublicBtn && noticeDraftBtn) {
        // 公開ボタン
        noticePublicBtn.addEventListener('click', () => {
          console.log('お知らせ公開ボタンがクリックされました');
          noticePublicBtn.classList.add('active');
          noticeDraftBtn.classList.remove('active');
          
          // 公開状態のアイテムだけを表示
          noticeItems.forEach(item => {
            const status = item.getAttribute('data-status');
            console.log('お知らせステータス:', status);
            if (status === 'public') {
              item.style.display = 'flex';
            } else {
              item.style.display = 'none';
            }
          });
        });
        
        // 下書きボタン
        noticeDraftBtn.addEventListener('click', () => {
          console.log('お知らせ下書きボタンがクリックされました');
          noticeDraftBtn.classList.add('active');
          noticePublicBtn.classList.remove('active');
          
          // 下書き状態のアイテムだけを表示
          noticeItems.forEach(item => {
            const status = item.getAttribute('data-status');
            if (status === 'draft') {
              item.style.display = 'flex';
            } else {
              item.style.display = 'none';
            }
          });
        });
      }
    }

    // ブログの切り替え - IDを使用
    const blogStatusWrapper = document.getElementById('blog-status-wrapper');
    if (blogStatusWrapper) {
      const blogPublicBtn = blogStatusWrapper.querySelector('button:nth-child(1)');
      const blogDraftBtn = blogStatusWrapper.querySelector('button:nth-child(2)');
      const blogItems = document.querySelectorAll('.posted_blog-item');

      console.log('ブログボタン:', blogPublicBtn, blogDraftBtn);
      console.log('ブログアイテム数:', blogItems.length);

      if (blogPublicBtn && blogDraftBtn) {
        // 公開ボタン
        blogPublicBtn.addEventListener('click', () => {
          console.log('ブログ公開ボタンがクリックされました');
          blogPublicBtn.classList.add('active');
          blogDraftBtn.classList.remove('active');
          
          // 公開状態のアイテムだけを表示
          blogItems.forEach(item => {
            const status = item.getAttribute('data-status');
            console.log('ブログアイテムステータス:', status);
            if (status === 'public') {
              item.style.display = 'block';
            } else {
              item.style.display = 'none';
            }
          });
        });
        
        // 下書きボタン
        blogDraftBtn.addEventListener('click', () => {
          console.log('ブログ下書きボタンがクリックされました');
          blogDraftBtn.classList.add('active');
          blogPublicBtn.classList.remove('active');
          
          // 下書き状態のアイテムだけを表示
          blogItems.forEach(item => {
            const status = item.getAttribute('data-status');
            if (status === 'draft') {
              item.style.display = 'block';
            } else {
              item.style.display = 'none';
            }
          });
        });
      }
    }
  });

  // 既存のすべての公開/下書き切り替えコードを削除し、以下のコードに置き換えてください

  // 公開/下書き切り替え機能
  document.addEventListener('DOMContentLoaded', function() {
    console.log('DOMContentLoaded イベントが発火しました');
    
    // お知らせの切り替え - IDを使用
    const noticeStatusWrapper = document.getElementById('notice-status-wrapper');
    if (noticeStatusWrapper) {
      console.log('お知らせステータスラッパーを検出:', noticeStatusWrapper);
      
      const noticePublicBtn = noticeStatusWrapper.querySelector('button:nth-child(1)');
      const noticeDraftBtn = noticeStatusWrapper.querySelector('button:nth-child(2)');
      const noticeItems = document.querySelectorAll('.posted_item');
      
      console.log('お知らせボタン:', noticePublicBtn, noticeDraftBtn);
      console.log('お知らせアイテム数:', noticeItems.length);
      
      // 初期表示（公開のみ表示）
      noticeItems.forEach(item => {
        const status = item.getAttribute('data-status');
        if (status === 'public') {
          item.style.display = 'flex';
        } else {
          item.style.display = 'none';
        }
      });
      
      if (noticePublicBtn && noticeDraftBtn) {
        // 公開ボタン
        noticePublicBtn.addEventListener('click', function() {
          console.log('お知らせ公開ボタンがクリックされました');
          noticePublicBtn.classList.add('active');
          noticeDraftBtn.classList.remove('active');
          
          // 公開状態のアイテムだけを表示
          noticeItems.forEach(item => {
            const status = item.getAttribute('data-status');
            console.log('お知らせステータス:', status);
            if (status === 'public') {
              item.style.display = 'flex';
            } else {
              item.style.display = 'none';
            }
          });
        });
        
        // 下書きボタン
        noticeDraftBtn.addEventListener('click', function() {
          console.log('お知らせ下書きボタンがクリックされました');
          noticeDraftBtn.classList.add('active');
          noticePublicBtn.classList.remove('active');
          
          // 下書き状態のアイテムだけを表示
          noticeItems.forEach(item => {
            const status = item.getAttribute('data-status');
            if (status === 'draft') {
              item.style.display = 'flex';
            } else {
              item.style.display = 'none';
            }
          });
        });
      }
    }
    
    // ブログの切り替え - IDを使用
    const blogStatusWrapper = document.getElementById('blog-status-wrapper');
    if (blogStatusWrapper) {
      console.log('ブログステータスラッパーを検出:', blogStatusWrapper);
      
      const blogPublicBtn = blogStatusWrapper.querySelector('button:nth-child(1)');
      const blogDraftBtn = blogStatusWrapper.querySelector('button:nth-child(2)');
      const blogItems = document.querySelectorAll('.posted_blog-item');
      
      console.log('ブログボタン:', blogPublicBtn, blogDraftBtn);
      console.log('ブログアイテム数:', blogItems.length);
      
      // 初期表示（公開のみ表示）
      blogItems.forEach(item => {
        const status = item.getAttribute('data-status');
        if (status === 'public') {
          item.style.display = 'block';
        } else {
          item.style.display = 'none';
        }
      });
      
      if (blogPublicBtn && blogDraftBtn) {
        // 公開ボタン
        blogPublicBtn.addEventListener('click', function() {
          console.log('ブログ公開ボタンがクリックされました');
          blogPublicBtn.classList.add('active');
          blogDraftBtn.classList.remove('active');
          
          // 公開状態のアイテムだけを表示
          blogItems.forEach(item => {
            const status = item.getAttribute('data-status');
            console.log('ブログアイテムステータス:', status);
            if (status === 'public') {
              item.style.display = 'block';
            } else {
              item.style.display = 'none';
            }
          });
        });
        
        // 下書きボタン
        blogDraftBtn.addEventListener('click', function() {
          console.log('ブログ下書きボタンがクリックされました');
          blogDraftBtn.classList.add('active');
          blogPublicBtn.classList.remove('active');
          
          // 下書き状態のアイテムだけを表示
          blogItems.forEach(item => {
            const status = item.getAttribute('data-status');
            if (status === 'draft') {
              item.style.display = 'block';
            } else {
              item.style.display = 'none';
            }
          });
        });
      }
    }
  });

  
  document.addEventListener('DOMContentLoaded', function() {
    // 既存のコードはそのままで、以下を追加

    // お知らせのタグフィルタリング
    const noticeTagSelect = document.querySelector('.posted .option_wrapper select');
    const noticeItems = document.querySelectorAll('.posted_item');
    
    if (noticeTagSelect) {
      console.log('お知らせタグセレクト検出:', noticeTagSelect);
      
      noticeTagSelect.addEventListener('change', function(e) {
        const selectedTag = e.target.value;
        console.log('選択されたお知らせタグ:', selectedTag);
        
        // すべてのお知らせアイテムをループ
        noticeItems.forEach(item => {
          // 現在のステータス表示設定を維持するため、現在の表示状態を確認
          const currentDisplay = item.style.display;
          const isCurrentlyVisible = currentDisplay !== 'none';
          
          // アイテムのタグを取得
          const itemTagsStr = item.getAttribute('data-tags') || '[]';
          let itemTags = [];
          try {
            itemTags = JSON.parse(itemTagsStr);
          } catch (e) {
            console.error('タグのJSONパースエラー:', e);
          }
          
          if (selectedTag === 'すべて') {
            // 「すべて」が選択された場合は、ステータスフィルタのみを適用
            // 現在表示されているものはそのまま表示
            if (isCurrentlyVisible) {
              item.style.display = 'flex';
            }
          } else {
            // 特定のタグが選択された場合
            const hasTag = Array.isArray(itemTags) && itemTags.includes(selectedTag);
            
            // タグを持っていて、かつ現在表示されているアイテムのみ表示
            if (hasTag) {
              item.style.display = 'flex';
            } else {
              item.style.display = 'none';
            }
          }
        });
      });
    }
    
    // ブログのタグフィルタリング
    const blogTagSelect = document.querySelector('.posted-blog .option_wrapper select');
    const blogItems = document.querySelectorAll('.posted_blog-item');
    
    if (blogTagSelect) {
      console.log('ブログタグセレクト検出:', blogTagSelect);
      
      blogTagSelect.addEventListener('change', function(e) {
        const selectedTag = e.target.value;
        console.log('選択されたブログタグ:', selectedTag);
        
        // すべてのブログアイテムをループ
        blogItems.forEach(item => {
          // 現在のステータス表示設定を維持するため、現在の表示状態を確認
          const currentDisplay = item.style.display;
          const isCurrentlyVisible = currentDisplay !== 'none';
          
          // アイテムのタグを取得
          const itemTagsStr = item.getAttribute('data-tags') || '[]';
          let itemTags = [];
          try {
            itemTags = JSON.parse(itemTagsStr);
          } catch (e) {
            console.error('タグのJSONパースエラー:', e);
          }
          
          if (selectedTag === 'すべて') {
            // 「すべて」が選択された場合は、ステータスフィルタのみを適用
            // 現在表示されているものはそのまま表示
            if (isCurrentlyVisible) {
              item.style.display = 'block';
            }
          } else {
            // 特定のタグが選択された場合
            const hasTag = Array.isArray(itemTags) && itemTags.includes(selectedTag);
            
            // タグを持っていて、かつ現在表示されているアイテムのみ表示
            if (hasTag) {
              item.style.display = 'block';
            } else {
              item.style.display = 'none';
            }
          }
        });
      });
    }
  });

  // タグフィルタリング機能を修正
  // 既存のタグフィルタリングコードを削除し、以下のコードに置き換えてください

  // タグフィルタリング機能
  window.addEventListener('load', function() {
    // お知らせのタグフィルタリング - ラジオボタンを使用
    const noticeTagRadios = document.querySelectorAll('#notice-option-wrapper input[type="radio"]');
    const noticeItems = document.querySelectorAll('.posted_item');
    
    if (noticeTagRadios.length > 0) {
      console.log('お知らせタグラジオボタン検出:', noticeTagRadios.length);
      
      noticeTagRadios.forEach(radio => {
        radio.addEventListener('change', function() {
          if (!this.checked) return;
          
          const selectedTag = this.value;
          console.log('選択されたお知らせタグ:', selectedTag);
          
          // すべてのお知らせアイテムをループ
          noticeItems.forEach(item => {
            // 現在のステータス表示設定を維持するため、現在の表示状態を確認
            const currentStatus = item.getAttribute('data-status');
            const isPublicVisible = document.querySelector('#notice-status-wrapper button:nth-child(1)').classList.contains('active');
            const isDraftVisible = document.querySelector('#notice-status-wrapper button:nth-child(2)').classList.contains('active');
            
            // 現在の表示状態に基づいて、このアイテムが表示されるべきかどうかを判断
            let shouldBeVisibleByStatus = false;
            if ((isPublicVisible && currentStatus === 'public') || 
                (isDraftVisible && currentStatus === 'draft')) {
              shouldBeVisibleByStatus = true;
            }
            
            // アイテムのタグを取得
            const itemTagsStr = item.getAttribute('data-tags') || '[]';
            let itemTags = [];
            try {
              itemTags = JSON.parse(itemTagsStr);
            } catch (e) {
              console.error('タグのJSONパースエラー:', e);
            }
            
            // タグフィルタリング
            if (selectedTag === 'すべて') {
              // 「すべて」が選択された場合は、ステータスフィルタのみを適用
              if (shouldBeVisibleByStatus) {
                item.style.display = 'flex';
              } else {
                item.style.display = 'none';
              }
            } else {
              // 特定のタグが選択された場合
              const hasTag = Array.isArray(itemTags) && itemTags.includes(selectedTag);
              
              // タグを持っていて、かつステータスフィルタに合致するアイテムのみ表示
              if (hasTag && shouldBeVisibleByStatus) {
                item.style.display = 'flex';
              } else {
                item.style.display = 'none';
              }
            }
          });
        });
      });
    }
    
    // ブログのタグフィルタリング - ラジオボタンを使用
    const blogTagRadios = document.querySelectorAll('#blog-option-wrapper input[type="radio"]');
    const blogItems = document.querySelectorAll('.posted_blog-item');
    
    if (blogTagRadios.length > 0) {
      console.log('ブログタグラジオボタン検出:', blogTagRadios.length);
      
      blogTagRadios.forEach(radio => {
        radio.addEventListener('change', function() {
          if (!this.checked) return;
          
          const selectedTag = this.value;
          console.log('選択されたブログタグ:', selectedTag);
          
          // すべてのブログアイテムをループ
          blogItems.forEach(item => {
            // 現在のステータス表示設定を維持するため、現在の表示状態を確認
            const currentStatus = item.getAttribute('data-status');
            const isPublicVisible = document.querySelector('#blog-status-wrapper button:nth-child(1)').classList.contains('active');
            const isDraftVisible = document.querySelector('#blog-status-wrapper button:nth-child(2)').classList.contains('active');
            
            // 現在の表示状態に基づいて、このアイテムが表示されるべきかどうかを判断
            let shouldBeVisibleByStatus = false;
            if ((isPublicVisible && currentStatus === 'public') || 
                (isDraftVisible && currentStatus === 'draft')) {
              shouldBeVisibleByStatus = true;
            }
            
            // アイテムのタグを取得
            const itemTagsStr = item.getAttribute('data-tags') || '[]';
            let itemTags = [];
            try {
              itemTags = JSON.parse(itemTagsStr);
            } catch (e) {
              console.error('タグのJSONパースエラー:', e);
            }
            
            // タグフィルタリング
            if (selectedTag === 'すべて') {
              // 「すべて」が選択された場合は、ステータスフィルタのみを適用
              if (shouldBeVisibleByStatus) {
                item.style.display = 'block';
              } else {
                item.style.display = 'none';
              }
            } else {
              // 特定のタグが選択された場合
              const hasTag = Array.isArray(itemTags) && itemTags.includes(selectedTag);
              
              // タグを持っていて、かつステータスフィルタに合致するアイテムのみ表示
              if (hasTag && shouldBeVisibleByStatus) {
                item.style.display = 'block';
              } else {
                item.style.display = 'none';
              }
            }
          });
        });
      });
    }
    
    // ステータスボタンのクリックイベントにタグフィルタの再適用を追加
    const noticePublicBtn = document.querySelector('#notice-status-wrapper button:nth-child(1)');
    const noticeDraftBtn = document.querySelector('#notice-status-wrapper button:nth-child(2)');
    
    if (noticePublicBtn && noticeDraftBtn) {
      noticePublicBtn.addEventListener('click', function() {
        // 公開ボタンのクラスを更新
        this.classList.add('active');
        noticeDraftBtn.classList.remove('active');
        
        // 公開状態のアイテムだけを表示
        noticeItems.forEach(item => {
          const status = item.getAttribute('data-status');
          if (status === 'public') {
            item.style.display = 'flex';
          } else {
            item.style.display = 'none';
          }
        });
        
        // タグフィルタを再適用
        const checkedNoticeRadio = document.querySelector('#notice-option-wrapper input[type="radio"]:checked');
        if (checkedNoticeRadio) {
          checkedNoticeRadio.dispatchEvent(new Event('change'));
        }
      });
      
      noticeDraftBtn.addEventListener('click', function() {
        // 下書きボタンのクラスを更新
        this.classList.add('active');
        noticePublicBtn.classList.remove('active');
        
        // 下書き状態のアイテムだけを表示
        noticeItems.forEach(item => {
          const status = item.getAttribute('data-status');
          if (status === 'draft') {
            item.style.display = 'flex';
          } else {
            item.style.display = 'none';
          }
        });
        
        // タグフィルタを再適用
        const checkedNoticeRadio = document.querySelector('#notice-option-wrapper input[type="radio"]:checked');
        if (checkedNoticeRadio) {
          checkedNoticeRadio.dispatchEvent(new Event('change'));
        }
      });
    }
    
    const blogPublicBtn = document.querySelector('#blog-status-wrapper button:nth-child(1)');
    const blogDraftBtn = document.querySelector('#blog-status-wrapper button:nth-child(2)');
    
    if (blogPublicBtn && blogDraftBtn) {
      blogPublicBtn.addEventListener('click', function() {
        // 公開ボタンのクラスを更新
        this.classList.add('active');
        blogDraftBtn.classList.remove('active');
        
        // 公開状態のアイテムだけを表示
        blogItems.forEach(item => {
          const status = item.getAttribute('data-status');
          if (status === 'public') {
            item.style.display = 'block';
          } else {
            item.style.display = 'none';
          }
        });
        
        // タグフィルタを再適用
        const checkedBlogRadio = document.querySelector('#blog-option-wrapper input[type="radio"]:checked');
        if (checkedBlogRadio) {
          checkedBlogRadio.dispatchEvent(new Event('change'));
        }
      });
      
      blogDraftBtn.addEventListener('click', function() {
        // 下書きボタンのクラスを更新
        this.classList.add('active');
        blogPublicBtn.classList.remove('active');
        
        // 下書き状態のアイテムだけを表示
        blogItems.forEach(item => {
          const status = item.getAttribute('data-status');
          if (status === 'draft') {
            item.style.display = 'block';
          } else {
            item.style.display = 'none';
          }
        });
        
        // タグフィルタを再適用
        const checkedBlogRadio = document.querySelector('#blog-option-wrapper input[type="radio"]:checked');
        if (checkedBlogRadio) {
          checkedBlogRadio.dispatchEvent(new Event('change'));
        }
      });
    }
    
    // 初期表示時にタグフィルタを適用
    const checkedNoticeRadio = document.querySelector('#notice-option-wrapper input[type="radio"]:checked');
    if (checkedNoticeRadio) {
      checkedNoticeRadio.dispatchEvent(new Event('change'));
    }
    
    if (checkedBlogRadio) {
      checkedBlogRadio.dispatchEvent(new Event('change'));
    }
  });

  // タグフィルタリング機能を修正
  window.addEventListener('load', function() {
    // 重複したイベントリスナーを削除するため、既存のリスナーをクリア
    const clearExistingListeners = (element) => {
      if (!element) return;
      const newElement = element.cloneNode(true);
      element.parentNode.replaceChild(newElement, element);
      return newElement;
    };

    // お知らせのタグフィルタリング - 新しいIDを使用
    const noticeTagSelect = document.getElementById('notice-option-wrapper')?.querySelector('select');
    const noticeItems = document.querySelectorAll('.posted_item');
    
    if (noticeTagSelect) {
      console.log('お知らせタグセレクト検出:', noticeTagSelect);
      
      // 既存のリスナーをクリア
      const newNoticeTagSelect = clearExistingListeners(noticeTagSelect);
      
      newNoticeTagSelect.addEventListener('change', function() {
        const selectedTag = this.value;
        console.log('選択されたお知らせタグ:', selectedTag);
        
        // すべてのお知らせアイテムをループ
        noticeItems.forEach(item => {
          // 現在のステータス表示設定を維持するため、現在の表示状態を確認
          const currentStatus = item.getAttribute('data-status');
          const isPublicVisible = document.querySelector('#notice-status-wrapper button:nth-child(1)').classList.contains('active');
          const isDraftVisible = document.querySelector('#notice-status-wrapper button:nth-child(2)').classList.contains('active');
          
          // 現在の表示状態に基づいて、このアイテムが表示されるべきかどうかを判断
          let shouldBeVisibleByStatus = false;
          if ((isPublicVisible && currentStatus === 'public') || 
              (isDraftVisible && currentStatus === 'draft')) {
            shouldBeVisibleByStatus = true;
          }
          
          // アイテムのタグを取得
          const itemTagsStr = item.getAttribute('data-tags') || '[]';
          let itemTags = [];
          try {
            itemTags = JSON.parse(itemTagsStr);
          } catch (e) {
            console.error('タグのJSONパースエラー:', e);
          }
          
          // タグフィルタリング
          if (selectedTag === 'すべて') {
            // 「すべて」が選択された場合は、ステータスフィルタのみを適用
            if (shouldBeVisibleByStatus) {
              item.style.display = 'flex';
            } else {
              item.style.display = 'none';
            }
          } else {
            // 特定のタグが選択された場合
            const hasTag = Array.isArray(itemTags) && itemTags.includes(selectedTag);
            
            // タグを持っていて、かつステータスフィルタに合致するアイテムのみ表示
            if (hasTag && shouldBeVisibleByStatus) {
              item.style.display = 'flex';
            } else {
              item.style.display = 'none';
            }
          }
        });
      });
    }
    
    // ブログのタグフィルタリング - 新しいIDを使用
    const blogTagSelect = document.getElementById('blog-option-wrapper')?.querySelector('select');
    const blogItems = document.querySelectorAll('.posted_blog-item');
    
    if (blogTagSelect) {
      console.log('ブログタグセレクト検出:', blogTagSelect);
      
      // 既存のリスナーをクリア
      const newBlogTagSelect = clearExistingListeners(blogTagSelect);
      
      newBlogTagSelect.addEventListener('change', function() {
        const selectedTag = this.value;
        console.log('選択されたブログタグ:', selectedTag);
        
        // すべてのブログアイテムをループ
        blogItems.forEach(item => {
          // 現在のステータス表示設定を維持するため、現在の表示状態を確認
          const currentStatus = item.getAttribute('data-status');
          const isPublicVisible = document.querySelector('#blog-status-wrapper button:nth-child(1)').classList.contains('active');
          const isDraftVisible = document.querySelector('#blog-status-wrapper button:nth-child(2)').classList.contains('active');
          
          // 現在の表示状態に基づいて、このアイテムが表示されるべきかどうかを判断
          let shouldBeVisibleByStatus = false;
          if ((isPublicVisible && currentStatus === 'public') || 
              (isDraftVisible && currentStatus === 'draft')) {
            shouldBeVisibleByStatus = true;
          }
          
          // アイテムのタグを取得
          const itemTagsStr = item.getAttribute('data-tags') || '[]';
          let itemTags = [];
          try {
            itemTags = JSON.parse(itemTagsStr);
          } catch (e) {
            console.error('タグのJSONパースエラー:', e);
          }
          
          // タグフィルタリング
          if (selectedTag === 'すべて') {
            // 「すべて」が選択された場合は、ステータスフィルタのみを適用
            if (shouldBeVisibleByStatus) {
              item.style.display = 'block';
            } else {
              item.style.display = 'none';
            }
          } else {
            // 特定のタグが選択された場合
            const hasTag = Array.isArray(itemTags) && itemTags.includes(selectedTag);
            
            // タグを持っていて、かつステータスフィルタに合致するアイテムのみ表示
            if (hasTag && shouldBeVisibleByStatus) {
              item.style.display = 'block';
            } else {
              item.style.display = 'none';
            }
          }
        });
      });
    }
    
    // 初期表示時にタグフィルタを適用
    if (noticeTagSelect) {
      noticeTagSelect.dispatchEvent(new Event('change'));
    }
    
    if (blogTagSelect) {
      blogTagSelect.dispatchEvent(new Event('change'));
    }
  });
</script>